#! /usr/bin/env

import io
import codecs
import logging

from copy import copy

"""from .. import rfc2396 as uri"""
from ..pep8 import MigratedClass


class GIFTError(Exception):
	"""Base class for all exceptions raised by this module."""
	pass


class DuplicateGIFTNAME(GIFTError):
	"""Raised by :py:func:`map_class_elements`

	Indicates an attempt to declare two classes with same GIFT name.
	"""
	pass


class GIFTAttributeSetter(GIFTError):
	"""Raised when a badly formed attribute mapping is found."""
	pass


class GIFTMissingResourceError(GIFTError):
	"""Raised when an entity cannot be found (e.g., missing file)"""
	pass


class GIFTMixedContentError(GIFTError):
	"""Raised by :meth:`Element.get_value`

	Indicates unexpected element children."""
	pass


class GIFTParentError(GIFTError):
	"""Raised by :meth:`Element.attach_to_parent`

	Indicates that the element was not an orphan."""
	pass


class GIFTValidityError(GIFTError):
	"""Base class for all validation errors.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L105

	Raised when a document or content model violates a validity
	constraint.  These errors can be generated by the parser (for
	example, when validating a document against a declared DTD) or by
	Elements themselves when content is encountered that does not fit
	content model expected.
	"""
	pass


class GIFTIDClashError(GIFTValidityError):
	"""A validity error caused by two elements with the same ID"""
	pass


class GIFTIDValueError(GIFTValidityError):
	"""A validity error caused by an element with an invalid ID

	ID attribute must satisfy the production for NAME."""
	pass


class GIFTUnknownChild(GIFTError):
	"""Raised by :meth:`Element.remove_child`

	Indicates that the child being removed was not found in the
	element's content."""
	pass


def is_s(c):
	"""Tests production [3] S

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L143

	Optimized for speed as this function is called a lot by the parser.

	Checked in Python 3.5 interpreter
	>>> c = ' '
	>>> c in "\x20\x09\x0A\x0D"
	True
	"""
	return c is not None and c in "\x20\x09\x0A\x0D"

"""
Variable definitions and functions below are for unicode and py2.

name_start_char = CharClass(
	':', ('A', 'Z'), '_', ('a', 'z'), (character(0xc0), character(0xd6)),
	(character(0xd8), character(0xf6)), (character(0xf8), character(0x02ff)),
	(character(0x0370), character(0x037d)),
	(character(0x037f), character(0x1fff)),
	(character(0x200c), character(0x200d)),
	(character(0x2070), character(0x218f)),
	(character(0x2c00), character(0x2fef)),
	(character(0x3001), character(0xd7ff)),
	(character(0xf900), character(0xfdcf)),
	(character(0xfdf0), character(0xfffd)))


def is_name_start_char(c):
	return name_start_char.test(c)

# is_name_start_char = name_start_char.test  # noqa (def used by decorator)

name_char = CharClass(name_start_char, '-', '.', ('0', '9'), character(0xb7),
                    (character(0x0300), character(0x036f)),
                    (character(0x203f), character(0x2040)))


def is_name_char(c):
    return name_char.test(c)

def is_valid_name(name):
	#Tests if name is a string matching production [5] Name
	if name:
		if not is_name_start_char(name[0]):
			return False
		for c in name[1:]:
			if not is_name_char(c):
				return False
		return True
	else:
		return False
"""


def escape_char_data(src, quote=False):
	"""Returns a string with GIFT reserved characters escaped.

	We also escape return characters to prevent them being ignored.
	If quote is True then the string is returned as a quoted attribute value.

	GIFT Special Characters: https://docs.moodle.org/23/en/GIFT_format#Special_Characters_.7E_.3D_.23_.7B_.7D
	Put backslash (\) before a control character
	"""
	data = []
	# apos = 0
	# quot = 0
	for c in src:
		if c == '~':
			data.append('\~')
		elif c == '=':
			data.append('\=')
		elif c == '#':
			data.append('\#')
		elif c == '{':
			data.append('\{')
		elif c == '}':
			data.append('\}')
		else:
			data.append(c)
	return ''.join(data)


class ElementType(object):
	"""Represents element type definitions.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1171

	"""
	#: Content type constant for EMPTY
	EMPTY = 0
	Empty = 0

	#: Content type constant for ANY
	ANY = 1
	Any = 1

	#: Content type constant for mixed content
	MIXED = 2
	Mixed = 2

	#: Content type constant for element content
	ELEMENT_CONTENT = 3
	ElementContent = 3

	def __init__(self):
		#: The entity in which this element was declared
		self.entity = None
		#: The name of this element
		self.name = None
		self.content_type = ElementType.EMPTY
		"""The content type of this element, one of the constants defined above."""
		self.content_model = None
		"""A :py:class:`GIFTContentParticle` instance which contains the element's
		content model or None in the case of EMPTY or ANY declarations."""
		self.particle_map = None
		"""A mapping used to validate the content model during parsing.  It maps the
		name of the first child element found to a list of :py:class:`GIFTNameParticle`
		instances that can represent it in the content model.  For more information
		see :py:attr:`GIFTNameParticle.particle_map`."""

	def build_model(self):
		"""Builds internal structures to support model validation."""
		if self.content_type == self.ELEMENT_CONTENT:
			self.particle_map = {}
			if not self.content_model.seek_particles(self.particle_map):
				# the entire content model is optional so add ETag mapping
				self.particle_map[''] = None
			exit_particles = {'': None}
			self.content_model.build_particle_maps(exit_particles)
		elif self.content_type == self.MIXED:
			self.particle_map = {}
			self.content_model.seek_particles(self.particle_map)
			self.particle_map[''] = None
			# always optional repeatable
			self.content_model.build_particle_maps(self.particle_map)

	def is_deterministic(self):
		"""Tests if the content model is deterministic.

		For degenerate cases (elements declared with ANY or EMPTY) the method
		always returns True."""
		if self.content_type == self.ELEMENT_CONTENT or \
				self.content_type == self.MIXED:
			return self.content_model.is_deterministic(self.particle_map)
		else:
			return True


class Node():
	"""Base class for Element and Document shared attributes.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L377

	GIFT documents are defined hierarchically, each element has a parent which
	is either another element or a GIFT document.
	"""
	def __init__(self, parent=None):
		self.parent = parent
		super().__init__()
		"""The parent of this element, for GIFT documents this attribute is
		used as a sentinel to simplify traversal of the hierarchy and is set
		to None."""

	def get_children(self):
		"""Returns an iterator over this object's children."""
		raise NotImplementedError

	@classmethod
	def get_element_class(cls, name):
		"""Returns a class object for representing an element

		name
			a unicode string representing the element name.

		The default implementation returns None - for elements this has
		the effect of deferring the call to the parent document (where
		this method is overridden to return :py:class:`Element`).

		This method is called immediately prior to :py:meth:`add_child`
		and (when applicable) :py:meth:`get_child_class`.

		The real purpose of this method is to allow an element class to
		directly control the way the name of a child element maps to the
		class used to represent it.  You would normally override this
		method in the :py:class:`Document` to map element names to
		classes but in some cases you may want to tweek the mapping at
		the individual element level.  For example, if the same element
		name is used for two different purposes in the same XML
		document.  Although confusing, this is allowed in XML schema."""
		return None


class Element(Node):
	"""Base class that represents all GIFT elements.
	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1247

	This class is usually used only as a default to represent elements
	with unknown content models or that require no special processing.
	The power of Pyslet's GIFT package comes when different classes are
	derived from this one to represent the different (classes of)
	elements defined by an application.  These derived classes will
	normally some form of custom serialisation behaviour (see below).

	Although derived classes are free to implement a wide range of
	python protocols they *must* always return True in truth tests.
	This ensures that derived classes are free to implement
	__len__ but bear in mind that an instance of a derived class for
	which __len__ returns 0 *must* still evaluate to True.

	Elements compare equal if their names, attribute lists and canonical
	children all compare equal.  No rich comparison methods are provided.

	In addition to truth testing, custom attribute serialisation
	requires a custom implementation of __getattr__, see below for more
	details.

	Elements are usually constructed by calling the parent element's (or
	document's) :meth:`Node.add_child` method.  When constructed
	directly, the constructor requires that the parent :class:`Node` be
	passed as an argument.  If you pass None then an orphan element is
	created (see :meth:`attach_to_parent`).

	Some aspects of the element's GIFT serialisation behaviour are controlled
	by special class attributes that can be set on derived classes.

	GIFTNAME
		The default name of the element the class represents.

	GIFTCONTENT
		The default content model of the element; one of the :py:class:`ElementType`
		constants.

	You can customise attribute mappings using the following special class attributes.

	ID
		The name of the ID attribute if the element has a unique ID.
		With this class attribute set, ID handling is automatic (see :py:meth:`set_id`
		and py:attr:`id` below).

	By default, attributes are simply stored as name/value character strings in an
	internal dictionary.  It is often more useful to map GIFT attributes directly onto
	similarly named attributes of the instances that represent each element.

	This mapping can be provided using class attributes of the form GIFTATTR_aname where
	/aname/ is the name of the attribute as it would appear in the element's tag.  There
	are a number of forms of attribute mapping.

	GIFTATTR_aname=<string>

		This form creates a simple mapping from the GIFT attribute 'aname' to a python
		attribute with a defined name.  For example, you might want to create a mapping
		like this to avoid a python reserved word::

				GIFTATTR_class="style_class"

		This allows GIFT elements like this::

				// text

		To be parsed into python objects that behave like this::

				element.style_class=="text"    # True

		If an instance is missing a python attribute corresponding to a defined GIFT
		attribute, or its value has been set to None, then the GIFT attribute is omitted
		from the element's tag when generating GIFT output.

	GIFTATTR_aname=(<string>, decode_function, encode_function)

		More complex attributes can be handled by setting GIFTATTR_aname to a tuple.
		The first item is the python attribute name (as above); the *decode_function* is a
		simple callable that takes a string argument and returns the decoded value of the
		attribute and the *encode_function* preforms the reverse transformation.

		The encode/decode functions can be None to indicate a no-operation.

		For example, you might want to create an integer attribute using something like::

				// source GIFT
				::Q1::

				# class attribute definition
				XMLATTR_title = ('Q1', str, str)

				# the resulting object behaves like this...
				element.title == 'Q1'    # True

		GIFTATTR_aname=(<string>, decode_function, encode_function, type)

			When GIFT attribute values are parsed from tags the option *type*
			component of the tuple descriptor can be used to indicate a multi-valued
			attribute.  For example, you might want to use a multi-valued mapping for
			GIFT attributes defined using one of the plural forms, IDREFS, ENTITIES, and
			NMTOKENS.

			If the *type* value is not None then the GIFT attribute value is first split
			by white-space, as per the GIFT specification, and then the decode function
			is applied to each resulting component.  The instance attribute is then set
			depending on the value of the *type*:

			list
				The instance attribute becomes a list, for example::

				// source GIFT
				{ =yellow # right; good! ~red # wrong, it's yellow ~blue # wrong, it's yellow}

				# class attribute definition
				XMLATTR_response = ('response', str, str, list)

				# resulting object behaves like this...
				element.response == ['=yellow', '#', 'right;', 'good!', '~red', '#', 'wrong,',
									'it's', 'yellow', '~blue', '#', 'wrong,', 'it's', 'yellow']

			NOTE: Ignoring support for dictionary mapping for now.

			When serialising to GIFT the reverse transformations are performed using the encode
			functions and the type (plain or list) of the attribute's *current* value.  The declared
			multi-valued type is ignored.  For dictionary values the order of the output values may
			not be the same as the order originally read from the GIFT input.

			Warning: Empty lists result in GIFT attribute values that are present but with empty strings.
			If you wish to omit these attributes in the output GIFT you must set the attribute value to None.

			Implementation note: internally, the GIFTATTR_* descriptors are parsed into two mappings the first
			time they are needed.  The forward map maps GIFT attribute names onto tuples of:

				(<python attribute name>, decode_function, type)

			The reverse map maps python attribute names onto a tuple of:

				(<gift attribute name>, encode_function)

	GIFT attribute names may contain characters that are not legal in Python syntax but automated attribute
	processing is still supported for these attributes even though the declaration cannot be written into
	the class definition.  Use the builtin function setattr immediately after the class is defined, for
	example::

		class MyElement(Element):
			pass

		setattr(MyElement, 'GIFTATTR_hyphen-attr', 'hyphen_attr')
	"""
	GIFTCONTENT = ElementType.MIXED

	def __init__(self, parent, name=None):
		super().__init__(parent)
		if name is None:
			if hasattr(self.__class__, 'GIFTNAME'):
				self.set_giftname(self.GIFTNAME)
			else:
				self.set_giftname(None)
		self.id = None
		self._attrs = {}
		self._children = []

	def __bool__(self):
		# All elements are considered non-zero; we implement this to
		# reduce spurious calls to __getattr__
		return True

	__nonzero__ = __bool__

	def set_giftname(self, name):
		"""Sets the name of this element

		name
			A character string.

		You will not normally need to call this method, it is called
		automatically during child creation.

		"""
		self.giftname = name

	def get_giftname(self):
		"""Returns the name of this element

		In the default implementation this is a simple character string.
		"""
		return self.giftname

	def get_document(self):
		"""Returns the document that contains the element.

		If the element is an orphan, or is the descendant of an orphan
		then None is returned."""
		if self.parent:
			if isinstance(self.parent, Document):
				return self.parent
			else:
				return self.parent.get_document()
		else:
			return None

	def set_id(self, id):
		"""Sets the id of the element

		The change is registered with the enclosing document.  If the id
		is already taken then :class:`GIFTIDClashError is raised.
		"""
		if not self.is_valid_name(id):
			raise GIFTIDValueError(id)
		doc = self.get_document()
		if doc:
			doc.unregister_element(self)
			self.id = id
			doc.register_element(self)
		else:
			self.id = id

	@classmethod
	def mangle_aname(cls, name):
		"""Returns a mangled attribute name

		A mangled attribute name is simple name prefixed with "GIFTATTR\_".
		"""
		return "GIFTATTR_" + name

	@classmethod
	def unmangle_aname(cls, mname):
		"""Returns an unmangled attribute name.

		If mname is not a mangled name, None is returned.  A mangled attribute
		name starts with "GIFTATTR\_".
		"""
		if mname.startswith('GIFTATTR_'):
			return mname[8:]
		else:
			return None

	@classmethod
	def _remap(cls):
		def nop(arg):
			return arg

		amap = {}
		armap = {}
		for mname in dir(cls):
			name = cls.unmangle_aname(mname)
			if name:
				setter = getattr(cls, mname)
				# if is_text(setter):
				if isinstance(setter, str):
					# use simple attribute assignment
					attr_name, encoder, decoder, vtype = \
						setter, None, None, None
				elif isinstance(setter, tuple):
					if len(setter) == 3:
						attr_name, decoder, encoder = setter
						vtype = None
					elif len(setter) == 4:
						attr_name, decoder, encoder, vtype = setter
					else:
						raise GIFTAttributeSetter(
							"bad GIFTATTR_ definition: %s attribute of %s" %
							(name, cls.__name__))
				else:
					raise GIFTAttributeSetter(
						"setting %s attribute of %s" %
						(name, cls.__name__))
				if encoder is None:
					encoder = nop
				if decoder is None:
					decoder = nop
				if vtype not in (list, dict, None):
					raise GIFTAttributeSetter(
						"Legacy GIFTATTR_ definition: %s attribute of %s" %
						(name, cls.__name__))
				amap[name] = (attr_name, decoder, vtype)
				armap[attr_name] = (name, encoder)
		setattr(cls, "_gift_amap", amap)
		setattr(cls, "_gift_armap", armap)

	@classmethod
	def _armap(cls):
		if "_gift_armap" not in cls.__dict__:
			cls._remap()
		return cls._gift_armap

	@classmethod
	def _amap(cls):
		if "_gift_amap" not in cls.__dict__:
			cls._remap()
		return cls._gift_amap

	def __getattr__(self, name):
		if name in self._armap():
			return None
		else:
			raise AttributeError(name)

	def get_attributes(self):
		"""Returns a dict mapping attribute names onto values.

		Each attribute value is represented as a character string.
		Derived classes MUST override this method if they define any
		custom attribute mappings.

		The dictionary returned represents a copy of the information
		in the element and so may be modified by the caller.
		"""
		attrs = copy(self._attrs)
		if self.id:
			attrs[self.__class__.ID] = self.id
		armap = self._armap()
		for attr_name, desc in dict.items(armap):
			name, encoder = desc
			value = getattr(self, attr_name, None)
			if isinstance(value, list):
				value = ' '.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict.items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = ' '.join(sorted(lvalue))
			elif value is not None:
				value = encoder(value)
			if value is not None:
				attrs[name] = value
		return attrs

	def set_attribute(self, name, value):
		"""Sets the value of an attribute.

		name
			The name of the attribute to set

		value
			The value of the attribute (as a character string) or None
			to remove the attribute.
		"""
		amap = self._amap()
		if name in amap:
			attr_name, decoder, vType = amap[name]
			if vType is list:
				if value is None:
					value = []
				else:
					value = value.split()
				setattr(self, attr_name, [decoder(v) for v in value])
			elif vType is dict:
				if value is None:
					value = []
				else:
					value = value.split()
				dvalue = {}
				for iv in (decoder(v) for v in value):
					dvalue[iv] = dvalue.get(iv, 0) + 1
				setattr(self, attr_name, dvalue)
			else:
				x = getattr(self, attr_name, None)
				if type(x) in (list, dict):
					logging.error(
						"Problem setting %s in %s: single value will overwrite"
						" List or Dict", name, self.__class__.__name__)
				if value is None:
					setattr(self, attr_name, None)
				else:
					setattr(self, attr_name, decoder(value))
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			self.set_id(value)
		else:
			if value is None:
				if name in self._attrs:
					del self._attrs[name]
				else:
					self._attrs[name] = value

	def get_attribute(self, name):
		"""Gets the value of a single attribute as a string.

		If the element has not attribute with *name* then KeyError is raised.

		This method searches the attribute mappings and will return attribute values obtained by
		encoding the associated objects according to the mapping.
		"""
		if name in self._attrs:
			return self._attrs[name]
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			return self.id
		else:
			amap = self._amap()
			if name in amap:
				attr_name, decoder, vType = amap[name]
				value = getattr(self, attr_name, None)
			else:
				value = None
			if value is None:
				raise KeyError("Attribute value undefined: %s" % repr(name))
			armap = self._armap()
			unusedName, encoder = armap[attr_name]
			if isinstance(value, list):
				value = ' '.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict.items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = ' '.join(sorted(lvalue))
			else:
				value = encoder(value)
			return value

	# def is_valid_name(self, value):
	# 	"""Returns True if a character string is a valid NAME

	# 	This test can be done standalone using the module function of
	# 	the same name (this implementation defaults to using that function).
	# 	By checking validity in the context of an element derived classes
	# 	may override this test.

	# 	This test is currently used only when checking IDs (see :meth:`set_id`)
	# 	"""
	# 	return is_valid_name(value)

	def is_empty(self):
		"""Whether this element *must* be empty.

		If the class defines the :attr:`GIFTCONTENT` attribute then the model
		is taken from there and this method returns True only if GIFTCONTENT is
		:attr:`ElementType.EMPTY`.

		Otherwise, the method defaults to False
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.EMPTY
		else:
			return False

	def is_mixed(self):
		"""Whether or not the element *may* contain mixed content.

		If the class defines the :attr:`GIFTCONTENT` attribute then the
		model is taken from there and this method returns True only if
		GIFTCONTENT is :attr:`ElementType.MIXED`.

		Otherwise, the method defaults to True
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.MIXED
		else:
			return True

	def get_children(self):
		"""Returns an iterable of the element's children.

		This method iterates through the internal list of children only.
		Derived classes with custom models (i.e., those that define
		attributes to customise child element creation) MUST override
		this method.

		Each child is either a character string or an instance of Element
		(or a derived class thereof).  We do not represent comments,
		processing instructions or other meta-markup.
		"""
		return iter(self._children)

	def get_canonical_children(self):
		"""Returns children with canonical white space

		A wrapper for :py:meth:`get_children` that returns at iterable of the element's
		children canonicalized for white space as follows.  We check the current setting
		of gift:space, returning the same list of children as :py:meth:`get_children` if
		'preserve' is in force.  Otherwise we remove any leading space and collapse all
		all others to a single space character.
		"""
		pass

	def _find_factory(self, child_class):
		if hasattr(self, child_class.__name__):
			return child_class.__name__
		else:
			for parent in child_class.__bases__:
				fname = self._find_factory(parent)
				if fname:
					return fname
			return None

	def get_or_add_child(self, child_class):
		"""Returns the first child of type child_class

		If there is no child of that class then a new child is added.
		"""
		children = self.find_children_depth_first(child_class, max_depth=1)
		try:
			return children.next()
		except StopIteration:
			return self.add_child(child_class)

	def add_child(self, child_class, name=None):
		"""Adds a new child of the given class attached to this element.

		child_class
			A class object (or callable) used to create a new instance.

		name
			The name given to the element (by the caller).  If no name is given
			then the default name for the child is used.  When the child returned
			is an existing instance, name is ignored.

		By default, an instance of child_class is created and attached
		to the internal list of child elements.

		Child creation can be customised to support a more natural
		mapping for structured elements as follows.  Firstly, the name
		of child_class (*not* the element name) is looked up in the
		parent (self), if there is no match, the method resolution order
		is followed for *child_class* looking up the names of each base
		in turn until a matching attribute is found.  If there are no
		matches then the default handling is performed.

		Otherwise, the behaviour is determined by the matching attribute
		as follows.

		1   If the attribute is None then a new instance of child_class
			is created and assigned to the attribute.
		2   If the attribute is a list then a new instance of child_class
			is created and appended to the attribute's value.
		3   Finally, if the attribute value is already an instance of
			child_class it is returned unchanged.
		4   Deprecated: A method attribute is called either without
			arguments (if the method name matches the child_class
			exactly) or with the child_class itself passed as an
			argument.  It must return the new child element.

		In summary, a new child is created and attached to the element's
		model *unless* the model supports a single element of the given
		child_class and the element already exists (as evidenced by an
		attribute with the name of child_class or one of its bases), in
		which case the existing instance is returned.
		"""
		if self.is_empty():
			self.validation_error("Unexpected child element", name)
		child = None
		factory_name = self._find_factory(child_class)
		try:
			if factory_name:
				factory = getattr(self, factory_name)
				if isinstance(factory, MethodType):
					warnings.warn(
						"%s.%s method-based content model is deprecated" %
						(type(self).__name__, factory_name),
						DeprecationWarning, stacklevel=3)
					if factory_name != child_class.__name__:
						child = factory(child_class)
					else:
						child = factory()
				elif factory is None:
					child = child_class(self)
					setattr(self, factory_name, child)
				elif isinstance(factory, list):
					child = child_class(self)
					factory.append(child)
				elif isinstance(factory, child_class):
					child = factory
					child.reset(True)
				else:
					raise TypeError(
						factory_name, repr(factory), repr(child_class))
				if child is not None:
					if name:
						child.set_giftname(name)
					return child
			# else fall through to the default processing...
			child = child_class(self)
			self._children.append(child)
			if name:
				child.set_giftname(name)
			return child
		except TypeError as e:
			import traceback
			logging.error("Error creating GIFT element: %s", e)
			traceback.print_exc()
			raise TypeError("Can't create %s in %s" %
				(child_class.__name__, self.__class__.__name__))

	def remove_child(self, child):
		"""Removes a child from this element's children.

		child
			A :class:`Element` instance that must be a direct child.
			That is, one that would be yielded by :meth:`get_children`.

		By default, we search the internal list of child elements.

		For content model customisation we follow the same name matching
		conventions as for child creation (see :meth:`add_child`).  If a
		matching attribute is found then we process them as follows:

		1. If the attribute's value is *child* then it is set to None,
		if it is not *child* then :class:`GIFTUnknownChild` is raised.

		2. If the attribute is a list then we remove *child* from the list.
		If *child* is not in the list :class:`GIFTUnknownChild` is raised.

		3. If the attribute is None then we raise :class:`GIFTUnknownChild`.
		"""
		if self.is_empty():
			raise GIFTUnknownChild(child.giftname)
		factory_name = self._find_factory(child.__class__)
		if factory_name:
			factory = getattr(self, factory_name)
			if factory is None:
				raise GIFTUnknownChild(child.giftname)
			elif isinstance(factory, list):
				match = False
				for i in range3(len(factory)):
					if factory[i] is child:
						child.detach_from_doc()
						child.parent = None
						del factory[i]
						match = True
						break
				if not match:
					raise GIFTUnknownChild(child.giftname)
			elif factory is child:
				# Single allowable child is replaced with None
				child.detach_from_doc()
				child.parent = None
				setattr(self, factory_name, None)
			else:
				raise TypeError("%s.%s in Element.remove_child" %
					(type(self).__name__, factory_name))
		else:
			match = False
			for i in range3(len(self._children)):
				if self._children[i] is child:
					child.detach_from_doc()
					child.parent = None
					del self._children[i]
					match = True
					break
			if not match:
				raise GIFTUnknownChild(child.giftname)

	def find_children(self, child_class, child_list, max=None):
		"""Finds children of a given class"""
		pass

	def find_children_breadth_first(self, child_class, sub_match=True,
		max_depth=1000, **kws):
		"""Generates all children of a given class"""
		pass

	def find_children_depth_first(self, child_class, sub_match=True,
		max_depth=1000, **kws):
		"""Generates all children of a given class"""
		pass

	def find_parent(self, parent_class):
		"""Finds the first parent of the given class.

		Traverses the hierarchy through parent elements until a matching
		parent is found or returns None.
		"""
		parent = self.parent
		while parent and not isinstance(parent, parent_class):
			if isinstance(parent, Element):
				parent = parent.parent
			else:
				parent = None
		return parent

	def attach_to_parent(self, parent):
		"""Called to attach an orphan element to a parent.

		This method is not normally needed, when creating GIFT elements you would
		normally call :meth:`add_child` on the parent which ensures that elements
		are create in the context of a parent node. The purpose of this method is
		to allow orphaned elements to be associated with a (new) parent.  For example,
		after being detached from one element hierarchy and attached to another.

		This method does not do any special handling of child elements, the caller takes
		responsibility for ensuring that this element will be returned by future calls
		to parent.get_children().  However, :py:meth:`attach_to_doc` is called to ensure
		id registrations are made.
		"""
		if self.parent:
			raise GIFTParentError("Expected orphan")
		self.parent = parent
		self.attach_to_doc()

	def attach_to_doc(self, doc=None):
		"""Called when the element is first attached to a document.

		This method is not normally needed.  When creating GIFT elements
		you would normally call :meth:`add_child` on the parent which ensures
		that elements are created in the context of a containing document.
		The purpose of this method is to allow orphaned elements to be
		associated with a parent (document) after creation.  For example,
		after being detached from one element hierarchy and attached to another
		(possibly in a different document).

		The default implementation ensures that any ID attributes belonging
		to this element or its descendents are registered.
		"""
		if doc is None:
			doc = self.get_document()
		if doc:
			if self.id:
				doc.register_element(self)
			for child in self.get_children():
				if isinstance(child, Element):
					child.attach_to_doc(doc)

	def detach_from_parent(self):
		"""Called to detach an element from its parent

		The result is that this element becomes an orphan.

		This method does not do any special handling of child elements,
		the caller takes responsibility for ensuring that this element
		will no longer be returned by future calls to the (former) parent's
		:meth:`get_children` method.

		We do call :py:meth:`detach_from_doc` to ensure id registrations
		are removed and :attr:`parent` is set to None.
		"""
		self.detach_from_doc()
		self.parent = None

	def detach_from_doc(self, doc=None):
		"""Called when an element is being detached from a document.

		doc
			The document the element is being detached from, if None
			then this is determined automatically.  Provided as an optimisation
			for speed when detaching large parts of the element hierarchy.

		The default implementation ensures that any ID attributes belonging
		to this element or its descendants are unregistered.
		"""
		if doc is None:
			doc = self.get_document()
		if doc:
			if self.id:
				doc.unregister_element(self)
			for child in self.get_children():
				if isinstance(child, Element):
					child.detach_from_doc(doc)

	def add_data(self, data):
		"""Adds a character string to this element's children.

		This method raises a validation error if the element cannot take
		data children."""
		data = str(data)
		if self.is_mixed():
			if self._children and isinstance(self._children[-1], str):
				# To ease the comparison function we collapse string children
				self._children[-1] = self._children[-1] + data
			else:
				self._children.append(data)
		else:
			ws = True
			for c in data:
				if not is_s(c):
					ws = False
					break
			if not ws:
				self.validation_error("Unexpected data", data)

	def content_changed(self):
		pass

	def generate_value(self):
		pass

	def get_value(self, ignore_elements=False):
		"""Returns a single object representing the element's content.

		ignore_elements
			If True then any elements found in mixed content are ignored.
			If False then any child elements cause :class:`GIFTMixedContentError`
			to be raised.

		The default implementation returns a character string and is only supported
		for elements where mixed content is permitted (:py:meth:`is_mixed`).  It uses
		:py:meth:`generate_value` to iterate through the children.

		If the element is empty an empty string is returned.

		Derived classes may return more complex objects, such as values of basic python
		types or class instances that better represent the content of the element.
		"""
		# equivalent to join_characters in py2
		return '.'.join(self.generate_value(ignore_elements))

	def set_value(self, value):
		"""Replaces the content of the element.

		value
			A character string used to replace the content of the
			element.  Derived classes may support a wider range of
			value types, if the default implementation encounters
			anything other than a character string it attempts to
			convert it before setting the content.

		The default implementation is only supported for elements
		where mixed content is permitted (see :py:meth:`is_mixed`)
		and only affects the internally maintained list of children.
		Elements with more complex mixed models MUST override this
		method.

		If *value is None then the element becomes empty.
		"""
		if not self.is_mixed():
			raise GIFTMixedContentError
		self.reset(False)
		if value is None:
			self._children = []
		else:
			self._children = [str(value)]

	def reset(self, reset_attrs=False):
		"""Resets all children (and optionally attribute values).

		reset_attrs
			Whether or not to reset attribute values too.

			Called by the default implementation of :meth:`set_value`
			with reset_attrs=False, removes all children from the
			internally maintained list of children.

			Called by the default implementation of :meth:`add_child`
			with reset_attrs=True when an existing element instnace is
			being recycled (obviating the constructor).  The default
			implementation removes only *unmapped* attribute values.
			Mapped attribute values are not reset.

		Derived classes should call this method if they override the
		implementation of :meth:`set_value`.

		Derived classes with custom content models, i.e., those that
		provide a custom implementation for :meth:`get_children`, must
		override this method and treat it as an event associated with
		parsing the start tag of the element.  (This method is also a
		useful signal for resetting an state used for validating custom
		content models.)

		Required children should be reset and optional children should
		be orphaned using :meth:`detach_from_parent` and any references
		to them in instance attributes removed. Failure to override this
		method will can result in the child elements accumulating from
		one read to the next.
		"""
		if reset_attrs:
			self._attrs = {}
		for child in self._children:
			if isinstance(child, Element):
				child.detach_from_doc()
				child.parent = None
		self._children = []

	def validation_error(self, msg, data=None, aname=None):
		"""Called when a validation error occurred in this element.

		msg
			Message suitable for logging and reporting the nature of
			the error.

		data
			The data that caused the error may be given in data.

		aname
			The attribute name may also be given indicating that the
			offending data was in an attribute of the element and not
			the element itself.

		The default implementation simply calls the containing Document's
		:meth:`Document.validation_error` method.  If the element is an
		orphan then :class:`GIFTValidityError` is raised directly with *msg*.
		"""
		doc = self.get_document()
		if doc:
			doc.validation_error(msg, self, data, aname)
		else:
			raise GIFTValidityError(msg)

	def sort_names(name_list):
		name_list.sort()

	def __eq__(self, other):
		"""Compares another element with this one.

		GIFTElement can only be compared with other Elements.
		"""
		if not isinstance(other, Element):
			return NotImplemented
		if self.giftname != other.giftname:
			return False
		self_attrs = self.get_attributes()
		self_attr_names = list(dict.keys(self_attrs))
		self.sort_names(self_attr_names)
		other_attrs = other.get_attributes()
		other_attr_names = list(dict.keys(other_attrs))
		other.sort_names(other_attr_names)
		if self_attr_names != other_attr_names:
			return False
		for i in range(len(self_attr_names)):
			self_aname = self_attr_names[i]
			if self_attrs[self_aname] != other_attrs[self_aname]:
				return False
		self_children = list(self.get_canonical_children())
		other_children = list(other.get_canonical_children())
		return self_children == other_children

	def __ne__(self, other):
		if not isinstance(other, Element):
			return NotImplemented
		return not self.__eq__(other)

	def __bytes__(self):
		"""Returns the GIFT element as a binary string.

		The resulting string is encoded with UTF-8
		"""
		s = io.BytesIO()
		for data in self.generate_gift():
			s.write(data.encode('utf-8'))
		return s.getvalue()

	def deepcopy(self, parent=None):
		pass

	def get_base(self):
		pass

	def set_base(self, base):
		pass

	def write_gift_attributes(self, attributes, root=False, **kws):
		"""Creates strings serialising the element's attributes

		attributes
			A list of character strings

		escape_function
			The function that will be used to escape character data.  The default is
			:func:`escape_char_data`.  Previous pyslet version kept escape_function parameter
			for backwards compatibility.

		root
			Indicates if this element should be treated as the root element.
			By default there is no special action required but derived classes
			may need to generate additional attributes, such as those that relate
			to the namespaces or schema used by the element.

		The attributes are generated as strings of the form 'name="value"' with values escaped
		appropriately for serialised GIFT output.  The attributes are always sorted into a
		predictable order (based on attribute name) to ensure that identical documents
		produce identical output.
		"""
		attrs = self.get_attributes()
		keys = list(dict.keys(attrs))
		self.sort_names(keys)
		for a in keys:
			attributes.append('%s=%s' % (a, escape_char_data(attrs[a], True)))

	def generate_gift(self, indent='', tab='\t', root=False, **kws):
		"""A generator that yields serialised GIFT

		This will need some thought to generate in GIFT format

		https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L2766

		Assume escape_function is escape_char_data

		indent (defaults to an empty string)
			The string to use for passing any inherited indent, used in combination
			with the tab parameter for pretty printing.  See below.

		tab (defaults to '\\t')
			Whether or not indentation will be used is determined by the tab parameter.
			If it is empty then no pretty-printing is performed for the element, otherwise
			the element will start with a line-feed followed by an inherited *indent* and
			finally followed by the content of *tab*.  For example, if you prefer to have your
			GIFT serialised with a 4-space indent then pass tab = '    '.

			If the element is in a context where pretty printing is not allowed
			(see :meth:`can_pretty_print`) then tab is ignored.

		root (defaults to False)
			Indicates if this is the root element of the document.  See
			:meth:`write_gift_attributes`.

		Yields character strings.
		"""
		pass

	def write_gift(self):
		"""Writes serialized GIFT to an output stream.

		https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L2850
		"""
		pass


class Document(Node):
	"""Base class for all GIFT documents.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L550

	With no arguments, a new Document is created with no base URI or root element.

	root
		If root is a class object (descended from :class:`Element`) it
		is used to create the root element of the document.

		If root is an orphan instance of :class:`Element` (i.e., it has no parent)
		it is used as the root element of the document and its
		:py:meth:`Element.attach_to_doc`
		method is called.

	base_uri
		See :meth:`set_base` for more information

	req_manager
		Sets the request manager object to use for future HTTP calls.
		Must be an instance of :class:`pyslet.http.client.Client`.
	"""

	def __init__(self, root=None):

		super().__init__()
		self.root = None
		"""The root element or None if no root element has been created yet.
		"""
		if root:
			if isinstance(root, Element):
				if root.parent:
					raise ValueError(
						"Element must be an orphan in Document constructor")
				self.root = root
				root.parent = self
				self.root.attach_to_doc(self)
			elif not issubclass(root, Element):
				raise ValueError
			else:
				self.root = root(self)
		self.idTable = {}

		def get_children(self):
			"""Yields the root element"""
			if self.root:
				yield self.root

		def __bytes__(self):
			"""Returns the GIFT document as a string"""
			pass
			"""
			s = io.BytesIO()
			self.write_txt(s, escape_char_data7)
			return s.getvalue()
			"""

		def __unicode__(self):
			"""Returns GIFT document as unicode string"""
			pass
			"""
			s = io.StringIO()
			for data in self.generate_txt(escape_char_data):
				s.write(data)
			return s.getvalue()
			"""

		def GIFTParser(self, entity):
			"""Creates a parser for this document

			https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L623

			entity
				The entity to parse the document from

			The default implementation creates an instance of :class:`GIFTParser`.

			This method allows some document classes to override the parser used to parse them.
			This method is only used when parsing existing document instances (see :py:meth:`read`
			for more information).

			Classes that override this method may still register themselves with
			:py:func:`register_doc_class` but if they do then the default :py:class:`GIFTParser` object
			will be used as automatic detection of document class is done by the parser itself
			based on the information in the prolog (and/or first element).
			"""
			from pyslet.gift.parser import GIFTParser
			return GIFTParser(entity)

			@classmethod
			def get_element_class(cls, name):
				"""Defaults to returning :class:`Element`.

				Derived classes override this method to enable the GIFT parser to create instances
				of custom classes based on the document context and element name.
				"""
				return Element

			def add_child(self, child_class, name=None):
				"""Creates the root element of the document.

				If there is already a root element it is detached from the document first using
				:py:meth:`Element.detach_from_doc`.

				Unlike :meth:`Element.add_child` there are no model customization options.  The
				root element is always found at :attr:`root`.
				"""
				if self.root:
					self.root.detach_from_doc()
					self.root.parent = None
					self.root = None
				child = child_class(self)
				if name:
					child.set_giftname(name)
				self.root = child
				return self.root

			def get_space(self):
				"""Returns the default space policy for the document.

				By default we return None, indicating that no policy is in force.
				Derived documents can override this behaviour to return either "preserve"
				or "default" to affect space handling.
				"""
				raise NotImplementedError

			def validation_error(self, msg, element, data=None, aname=None):
				"""Called when a validation error is triggered.

				msg
					contains a brief message suitable for describing the error
					in a log file.
				element
					the element in which the validation error occurred
					data, aname

				See :meth:`Element.validation_error`.

				Prior to raising :class:`GIFTValidityError` this method logs a
				suitable message at WARN level."""
				if aname:
					logging.warning("%s (in %s.%s) %s", msg, aname,
						"" if data is None else repr(data))
				else:
					logging.warning("%s (in %s) %s", msg, element.giftname,
						"" if data is None else repr(data))
				raise GIFTValidityError("%s (in %s)" % (msg, element.giftname))

			def read(self, src=None, **kws):
				"""Reads this document, parsing it from a source stream.

				With no arguments the document is read from the
				:py:attr:`base_uri` which must have been specified on
				construction or with a call to the :py:meth:`set_base` method.
				src (defaults to None)

				You can override the document's base URI by passing a value
				for *src* which may be an instance of :py:class:`GIFTEntity`
				or a file-like object suitable for passing to
				:meth:`read_from_stream`.
				"""
				if src:
					# Read from this stream, ignore base_uri
					if isinstance(src, GIFTEntity):
						self.read_from_entity(src)
					else:
						self.read_from_stream(src)
				else:
					with GIFTEntity() as e:
						self.read_from_entity(e)

			def read_from_stream(self, src):
				"""Reads this document from a stream

				src
					Any object that can be passed to :class:`GIFTEntity`'s
					constructor.
				"""
				self.data = []
				e = GIFTEntity()
				self.read_from_entity(e)

			def read_from_entity(self, e):
				"""Reads this document from an entity

				e
					A :class:`GIFTEntity` instance.

				The document is read from the current position in the entity.
				"""
				self.data = []
				parser = self.GIFTParser(e)
				parser.parse_document(self)

			def create(self, **kws):
				"""Creates the Document.

				Only documents with file type baseURIs are supported.
				"""
				pass

			def generate_gift(self):
				"""A generator that yields serialised XML

				Assume UTF-8 encoding.

				Assume escape_char_data is escape_function.

				Yields character strings.
				"""
				if self.root:
					for s in self.root.generate_gift(root=True):
						yield s

			def write_gift(self, writer):
				"""Writes serialized GIFT to an output stream

				writer
					A file or file-like object operating in binary mode.

				The other arguments follow the same pattern as :meth:`generate_gift` which
				this method uses to create the output which is always UTF-8 encoded.
				"""
				for s in self.generate_gift():
					writer.write(s)

			def update(self, **kws):
				"""Updates the Document.

				Update outputs the document as a GIFT stream.
				The stream is written to the base_uri which must already exist.
				"""
				pass

			def diff_string(self, other_doc, before=10, after=5):
				"""Compares GIFT documents

				other_doc
					Another :class:`Document` instance to compare with.

				before (default 10)
					Number of lines before the first difference to output

				after (default 5)
					Number of lines after the first difference to output

				The two documents are converted to character strings and then
				compared line by line until a difference is found.  The result
				is suitable for logging or error reporting.  Used mainly to make the
				output of unittests easier to understand.
				"""
				pass


class GIFTEntity(MigratedClass):
	"""Represents a GIFT entity.

	Note: IGNORES URIs for now.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L3188

	This object serves two purposes: it acts as both the object used to store
	information about declared entities and also as a parser for feeding unicode
	characters to the main :py:class:`GIFTParser`.

	src
		May be a character string, or any object that supports
		file-like behaviour (seek and read).

		If provided, the corresponding open method is called immediately, see
		:meth:`open_string` and :meth:`open_file`.

	encoding
		If src is not None then this value will be passed when opening the entity
		reader.

	GIFTEntity objects act as context managers, hence it is possible to use::

		with GIFTEntity(src=URI.from_octets('mydata.txt')) as e:
			# process the entity here, will automatically close

	In Python 3.5 REPL:
	>>> import pyslet.rfc2396 as uri
	>>> uri.URI.from_octets('mygift.txt')
	<pyslet.rfc2396.URI object at 0x10225cfd0>
	"""
	def __init__(self, src=None, **kws):
		self.data_source = None
		self.char_source = None
		self.close_source = False
		self.the_char = None
		"""The character at the current position in the entity"""
		self.line_num = None
		"""The current line number within the entity (first line is line 1)"""
		self.line_pos = None
		"""The current character position within the entity (first char is 1)"""
		self.buff_text = ''
		self.base_pos = None

	chunk_size = io.DEFAULT_BUFFER_SIZE
	"""Characters are read from the data_source in chunks.
	The default chunk size is set from io.DEFAULT_BUFFER_SIZE, typically 8KB.
	"""

	def is_open(self):
		"""Returns True if the entity is open for reading."""
		return not (self.char_source is None)

	def open_unicode(self, src):
		"""Opens the entity from a unicode string."""
		self.data_source = None
		self.chunk = GIFTEntity.chunk_size
		self.char_source = io.StringIO(src)
		self.close_source = True
		self.base_pos = self.char_source.tell()
		self.reset()

	def open_file(self, src):
		"""Opens the entity from a file

		src
			An existing (open) binary file.
		"""
		self.data_source = src
		self.char_source = codecs.getreader('utf-8')(self.data_source)
		self.chunk = 1
		self.base_pos = self.char_source.tell()
		self.reset()

	def reset(self):
		"""Resets an open entity

		The entity returns to the first character in the entity."""
		if self.char_source is None:
			self.the_char = None
			self.base_pos = None
		else:
			self.char_source.seek(self.base_pos)
			self.the_char = ''
		self.line_num = 1
		self.line_pos = 0
		self.chars = ''
		self.char_seek = self.base_pos
		self.char_pos = -1
		self.ignore_lf = False
		self.next_char()

	def get_position_str(self):
		"""A short string describing the current position.

		For example, if the current character is pointing to character 6 of line 4
		then it will return the string 'Line 4.6'
		"""
		return "Line %i.%i" % (self.line_num, self.line_pos)

	def next_char(self):
		"""Advances to the next character in an open entity.

		This method takes care of the End-of-Line handling rules which force us to
		remove any CR characters and replace them with LF if they appear no their own or
		to silently drop them if they appear as part of a CR-LEF combination.
		"""
		if self.the_char is None:
			return
		self.char_pos = self.char_pos + 1
		self.line_pos = self.line_pos + 1
		if self.char_pos >= len(self.chars):
			self.char_seek = self.char_source.tell()
			self.chars = self.char_source.read(self.chunk)
			self.char_pos = 0
		if self.char_pos >= len(self.chars):
			self.the_char = None
		else:
			self.the_char = self.chars[self.char_pos]
			if self.the_char == '\x0D':
				# change to a line feed and ignore the next line feed
				self.the_char = '\x0A'
				self.ignore_lf = True
				self.next_line()
			elif self.the_char == '\x0A':
				if self.ignore_lf:
					self.ignore_lf = False
					self.next_char()
				else:
					self.next_line()
			else:
				self.ignore_lf = False

	# magic_table = {}

	def next_line(self):
		"""Called when the entity reader detects a new line.

		This method increases the internal line count and resets the
		character position to the beginning of the line.  You will not
		normally need to call this directly as line handling is done
		automatically by :py:meth:`next_char`.
		"""
		self.line_num = self.line_num + 1
		self.line_pos = 0

	def close(self):
		"""Closes the entity."""
		if self.close_source:
			if self.char_source is not None:
				self.char_source.close()
				self.char_source = None
			if self.data_source is not None:
				self.data_source.close()
				self.data_source = None
			self.close_source = False
		self.the_char = None
		self.line_num = None
		self.line_pos = None

	def __enter__(self):
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		self.close()
