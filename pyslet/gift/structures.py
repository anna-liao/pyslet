#! /usr/bin/env

import io
import codecs
import logging

from copy import copy

"""from .. import rfc2396 as uri"""
from ..pep8 import MigratedClass


class GIFTError(Exception):
	"""Base class for all exceptions raised by this module."""
	pass


class GIFTAttributeSetter(GIFTError):
	"""Raised when a badly formed attribute mapping is found."""
	pass


class GIFTValidityError(GIFTError):
	"""Base class for all validation errors.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L105

	Raised when a document or content model violates a validity
	constraint.  These errors can be generated by the parser (for
	example, when validating a document against a declared DTD) or by
	Elements themselves when content is encountered that does not fit
	content model expected.
	"""
	pass


class GIFTIDClashError(GIFTValidityError):
	"""A validity error caused by two elements with the same ID"""
	pass


class GIFTIDValueError(GIFTValidityError):
	"""A validity error caused by an element with an invalid ID

	ID attribute must satisfy the production for NAME."""
	pass


def is_s(c):
	"""Tests production [3] S

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L143

	Optimized for speed as this function is called a lot by the parser.

	Checked in Python 3.5 interpreter
	>>> c = ' '
	>>> c in "\x20\x09\x0A\x0D"
	True
	"""
	return c is not None and c in "\x20\x09\x0A\x0D"

"""
Variable definitions and functions below are for unicode and py2.

name_start_char = CharClass(
	':', ('A', 'Z'), '_', ('a', 'z'), (character(0xc0), character(0xd6)),
	(character(0xd8), character(0xf6)), (character(0xf8), character(0x02ff)),
	(character(0x0370), character(0x037d)),
	(character(0x037f), character(0x1fff)),
	(character(0x200c), character(0x200d)),
	(character(0x2070), character(0x218f)),
	(character(0x2c00), character(0x2fef)),
	(character(0x3001), character(0xd7ff)),
	(character(0xf900), character(0xfdcf)),
	(character(0xfdf0), character(0xfffd)))


def is_name_start_char(c):
	return name_start_char.test(c)

# is_name_start_char = name_start_char.test  # noqa (def used by decorator)

name_char = CharClass(name_start_char, '-', '.', ('0', '9'), character(0xb7),
                    (character(0x0300), character(0x036f)),
                    (character(0x203f), character(0x2040)))


def is_name_char(c):
    return name_char.test(c)

def is_valid_name(name):
	#Tests if name is a string matching production [5] Name
	if name:
		if not is_name_start_char(name[0]):
			return False
		for c in name[1:]:
			if not is_name_char(c):
				return False
		return True
	else:
		return False
"""


class ElementType(object):
	"""Represents element type definitions.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1171

	"""
	#: Content type constant for EMPTY
	EMPTY = 0
	Empty = 0

	#: Content type constant for ANY
	ANY = 1
	Any = 1

	#: Content type constant for mixed content
	MIXED = 2
	Mixed = 2

	#: Content type constant for element content
	ELEMENT_CONTENT = 3
	ElementContent = 3

	def __init__(self):
		#: The entity in which this element was declared
		self.entity = None
		#: The name of this element
		self.name = None
		self.content_type = ElementType.EMPTY
		"""The content type of this element, one of the constants defined above."""
		self.content_model = None
		"""A :py:class:`GIFTContentParticle` instance which contains the element's
		content model or None in the case of EMPTY or ANY declarations."""
		self.particle_map = None
		"""A mapping used to validate the content model during parsing.  It maps the
		name of the first child element found to a list of :py:class:`GIFTNameParticle`
		instances that can represent it in the content model.  For more information
		see :py:attr:`GIFTNameParticle.particle_map`."""

	def build_model(self):
		"""Builds internal structures to support model validation."""
		if self.content_type == self.ELEMENT_CONTENT:
			self.particle_map = {}
			if not self.content_model.seek_particles(self.particle_map):
				# the entire content model is optional so add ETag mapping
				self.particle_map[''] = None
			exit_particles = {'': None}
			self.content_model.build_particle_maps(exit_particles)
		elif self.content_type == self.MIXED:
			self.particle_map = {}
			self.content_model.seek_particles(self.particle_map)
			self.particle_map[''] = None
			# always optional repeatable
			self.content_model.build_particle_maps(self.particle_map)

	def is_deterministic(self):
		"""Tests if the content model is deterministic.

		For degenerate cases (elements declared with ANY or EMPTY) the method
		always returns True."""
		if self.content_type == self.ELEMENT_CONTENT or \
				self.content_type == self.MIXED:
			return self.content_model.is_deterministic(self.particle_map)
		else:
			return True


class Node():
	"""Base class for Element and Document shared attributes.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L377

	GIFT documents are defined hierarchically, each element has a parent which
	is either another element or a GIFT document.
	"""
	def __init__(self, parent=None):
		self.parent = parent
		super().__init__()
		"""The parent of this element, for GIFT documents this attribute is
		used as a sentinel to simplify traversal of the hierarchy and is set
		to None."""

	def get_children(self):
		"""Returns an iterator over this object's children."""
		raise NotImplementedError

	@classmethod
	def get_element_class(cls, name):
		"""Returns a class object for representing an element

		name
			a unicode string representing the element name.

		The default implementation returns None - for elements this has
		the effect of deferring the call to the parent document (where
		this method is overridden to return :py:class:`Element`).

		This method is called immediately prior to :py:meth:`add_child`
		and (when applicable) :py:meth:`get_child_class`.

		The real purpose of this method is to allow an element class to
		directly control the way the name of a child element maps to the
		class used to represent it.  You would normally override this
		method in the :py:class:`Document` to map element names to
		classes but in some cases you may want to tweek the mapping at
		the individual element level.  For example, if the same element
		name is used for two different purposes in the same XML
		document.  Although confusing, this is allowed in XML schema."""
		return None


class Element(Node):
	"""Base class that represents all GIFT elements.
	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1247

	This class is usually used only as a default to represent elements
	with unknown content models or that require no special processing.
	The power of Pyslet's GIFT package comes when different classes are
	derived from this one to represent the different (classes of)
	elements defined by an application.  These derived classes will
	normally some form of custom serialisation behaviour (see below).

	Although derived classes are free to implement a wide range of
	python protocols they *must* always return True in truth tests.
	This ensures that derived classes are free to implement
	__len__ but bear in mind that an instance of a derived class for
	which __len__ returns 0 *must* still evaluate to True.

	Elements compare equal if their names, attribute lists and canonical
	children all compare equal.  No rich comparison methods are provided.

	In addition to truth testing, custom attribute serialisation
	requires a custom implementation of __getattr__, see below for more
	details.

	Elements are usually constructed by calling the parent element's (or
	document's) :meth:`Node.add_child` method.  When constructed
	directly, the constructor requires that the parent :class:`Node` be
	passed as an argument.  If you pass None then an orphan element is
	created (see :meth:`attach_to_parent`).

	Some aspects of the element's GIFT serialisation behaviour are controlled
	by special class attributes that can be set on derived classes.

	GIFTNAME
		The default name of the element the class represents.

	GIFTCONTENT
		The default content model of the element; one of the :py:class:`ElementType`
		constants.

	You can customise attribute mappings using the following special class attributes.

	ID
		The name of the ID attribute if the element has a unique ID.
		With this class attribute set, ID handling is automatic (see :py:meth:`set_id`
		and py:attr:`id` below).

	By default, attributes are simply stored as name/value character strings in an
	internal dictionary.  It is often more useful to map GIFT attributes directly onto
	similarly named attributes of the instances that represent each element.

	This mapping can be provided using class attributes of the form GIFTATTR_aname where
	/aname/ is the name of the attribute as it would appear in the element's tag.  There
	are a number of forms of attribute mapping.

	GIFTATTR_aname=<string>

		This form creates a simple mapping from the GIFT attribute 'aname' to a python
		attribute with a defined name.  For example, you might want to create a mapping
		like this to avoid a python reserved word::

				GIFTATTR_class="style_class"

		This allows GIFT elements like this::

				// text

		To be parsed into python objects that behave like this::

				element.style_class=="text"    # True

		If an instance is missing a python attribute corresponding to a defined GIFT
		attribute, or its value has been set to None, then the GIFT attribute is omitted
		from the element's tag when generating GIFT output.

	GIFTATTR_aname=(<string>, decode_function, encode_function)

		More complex attributes can be handled by setting GIFTATTR_aname to a tuple.
		The first item is the python attribute name (as above); the *decode_function* is a
		simple callable that takes a string argument and returns the decoded value of the
		attribute and the *encode_function* preforms the reverse transformation.

		The encode/decode functions can be None to indicate a no-operation.

		For example, you might want to create an integer attribute using something like::

				// source GIFT
				::Q1::

				# class attribute definition
				XMLATTR_title = ('Q1', str, str)

				# the resulting object behaves like this...
				element.title == 'Q1'    # True

		GIFTATTR_aname=(<string>, decode_function, encode_function, type)

			When GIFT attribute values are parsed from tags the option *type*
			component of the tuple descriptor can be used to indicate a multi-valued
			attribute.  For example, you might want to use a multi-valued mapping for
			GIFT attributes defined using one of the plural forms, IDREFS, ENTITIES, and
			NMTOKENS.

			If the *type* value is not None then the GIFT attribute value is first split
			by white-space, as per the GIFT specification, and then the decode function
			is applied to each resulting component.  The instance attribute is then set
			depending on the value of the *type*:

			list
				The instance attribute becomes a list, for example::

				// source GIFT
				{ =yellow # right; good! ~red # wrong, it's yellow ~blue # wrong, it's yellow}

				# class attribute definition
				XMLATTR_response = ('response', str, str, list)

				# resulting object behaves like this...
				element.response == ['=yellow', '#', 'right;', 'good!', '~red', '#', 'wrong,',
									'it's', 'yellow', '~blue', '#', 'wrong,', 'it's', 'yellow']

			NOTE: Ignoring support for dictionary mapping for now.

			When serialising to GIFT the reverse transformations are performed using the encode
			functions and the type (plain or list) of the attribute's *current* value.  The declared
			multi-valued type is ignored.  For dictionary values the order of the output values may
			not be the same as the order originally read from the GIFT input.

			Warning: Empty lists result in GIFT attribute values that are present but with empty strings.
			If you wish to omit these attributes in the output GIFT you must set the attribute value to None.

			Implementation note: internally, the GIFTATTR_* descriptors are parsed into two mappings the first
			time they are needed.  The forward map maps GIFT attribute names onto tuples of:

				(<python attribute name>, decode_function, type)

			The reverse map maps python attribute names onto a tuple of:

				(<gift attribute name>, encode_function)

	GIFT attribute names may contain characters that are not legal in Python syntax but automated attribute
	processing is still supported for these attributes even though the declaration cannot be written into
	the class definition.  Use the builtin function setattr immediately after the class is defined, for
	example::

		class MyElement(Element):
			pass

		setattr(MyElement, 'GIFTATTR_hyphen-attr', 'hyphen_attr')
	"""
	GIFTCONTENT = ElementType.MIXED

	def __init__(self, parent, name=None):
		super().__init__(parent)
		if name is None:
			if hasattr(self.__class__, 'GIFTNAME'):
				self.set_giftname(self.GIFTNAME)
			else:
				self.set_giftname(None)
		self.id = None
		self._attrs = {}
		self._children = []

	def __bool__(self):
		# All elements are considered non-zero; we implement this to
		# reduce spurious calls to __getattr__
		return True

	__nonzero__ = __bool__

	def set_giftname(self, name):
		"""Sets the name of this element

		name
			A character string.

		You will not normally need to call this method, it is called
		automatically during child creation.

		"""
		self.giftname = name

	def get_giftname(self):
		"""Returns the name of this element

		In the default implementation this is a simple character string.
		"""
		return self.giftname

	def get_document(self):
		"""Returns the document that contains the element.

		If the element is an orphan, or is the descendant of an orphan
		then None is returned."""
		if self.parent:
			if isinstance(self.parent, Document):
				return self.parent
			else:
				return self.parent.get_document()
		else:
			return None

	def set_id(self, id):
		"""Sets the id of the element

		The change is registered with the enclosing document.  If the id
		is already taken then :class:`GIFTIDClashError is raised.
		"""
		if not self.is_valid_name(id):
			raise GIFTIDValueError(id)
		doc = self.get_document()
		if doc:
			doc.unregister_element(self)
			self.id = id
			doc.register_element(self)
		else:
			self.id = id

	@classmethod
	def mangle_aname(cls, name):
		"""Returns a mangled attribute name

		A mangled attribute name is simple name prefixed with "GIFTATTR\_".
		"""
		return "GIFTATTR_" + name

	@classmethod
	def unmangle_aname(cls, mname):
		"""Returns an unmangled attribute name.

		If mname is not a mangled name, None is returned.  A mangled attribute
		name starts with "GIFTATTR\_".
		"""
		if mname.startswith('GIFTATTR_'):
			return mname[8:]
		else:
			return None

	@classmethod
	def _remap(cls):
		def nop(arg):
			return arg

		amap = {}
		armap = {}
		for mname in dir(cls):
			name = cls.unmangle_aname(mname)
			if name:
				setter = getattr(cls, mname)
				# if is_text(setter):
				if isinstance(setter, str):
					# use simple attribute assignment
					attr_name, encoder, decoder, vtype = \
						setter, None, None, None
				elif isinstance(setter, tuple):
					if len(setter) == 3:
						attr_name, decoder, encoder = setter
						vtype = None
					elif len(setter) == 4:
						attr_name, decoder, encoder, vtype = setter
					else:
						raise GIFTAttributeSetter(
							"bad GIFTATTR_ definition: %s attribute of %s" %
							(name, cls.__name__))
				else:
					raise GIFTAttributeSetter(
						"setting %s attribute of %s" %
						(name, cls.__name__))
				if encoder is None:
					encoder = nop
				if decoder is None:
					decoder = nop
				if vtype not in (list, dict, None):
					raise GIFTAttributeSetter(
						"Legacy GIFTATTR_ definition: %s attribute of %s" %
						(name, cls.__name__))
				amap[name] = (attr_name, decoder, vtype)
				armap[attr_name] = (name, encoder)
		setattr(cls, "_gift_amap", amap)
		setattr(cls, "_gift_armap", armap)

	@classmethod
	def _armap(cls):
		if "_gift_armap" not in cls.__dict__:
			cls._remap()
		return cls._gift_armap

	@classmethod
	def _amap(cls):
		if "_gift_amap" not in cls.__dict__:
			cls._remap()
		return cls._gift_amap

	def __getattr__(self, name):
		if name in self._armap():
			return None
		else:
			raise AttributeError(name)

	def get_attributes(self):
		"""Returns a dict mapping attribute names onto values.

		Each attribute value is represented as a character string.
		Derived classes MUST override this method if they define any
		custom attribute mappings.

		The dictionary returned represents a copy of the information
		in the element and so may be modified by the caller.
		"""
		attrs = copy(self._attrs)
		if self.id:
			attrs[self.__class__.ID] = self.id
		armap = self._armap()
		for attr_name, desc in dict.items(armap):
			name, encoder = desc
			value = getattr(self, attr_name, None)
			if isinstance(value, list):
				value = ' '.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict.items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = ' '.join(sorted(lvalue))
			elif value is not None:
				value = encoder(value)
			if value is not None:
				attrs[name] = value
		return attrs

	def set_attribute(self, name, value):
		"""Sets the value of an attribute.

		name
			The name of the attribute to set

		value
			The value of the attribute (as a character string) or None
			to remove the attribute.
		"""
		amap = self._amap()
		if name in amap:
			attr_name, decoder, vType = amap[name]
			if vType is list:
				if value is None:
					value = []
				else:
					value = value.split()
				setattr(self, attr_name, [decoder(v) for v in value])
			elif vType is dict:
				if value is None:
					value = []
				else:
					value = value.split()
				dvalue = {}
				for iv in (decoder(v) for v in value):
					dvalue[iv] = dvalue.get(iv, 0) + 1
				setattr(self, attr_name, dvalue)
			else:
				x = getattr(self, attr_name, None)
				if type(x) in (list, dict):
					logging.error(
						"Problem setting %s in %s: single value will overwrite"
						" List or Dict", name, self.__class__.__name__)
				if value is None:
					setattr(self, attr_name, None)
				else:
					setattr(self, attr_name, decoder(value))
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			self.set_id(value)
		else:
			if value is None:
				if name in self._attrs:
					del self._attrs[name]
				else:
					self._attrs[name] = value

	def get_attribute(self, name):
		"""Gets the value of a single attribute as a string.

		If the element has not attribute with *name* then KeyError is raised.

		This method searches the attribute mappings and will return attribute values obtained by
		encoding the associated objects according to the mapping.
		"""
		if name in self._attrs:
			return self._attrs[name]
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			return self.id
		else:
			amap = self._amap()
			if name in amap:
				attr_name, decoder, vType = amap[name]
				value = getattr(self, attr_name, None)
			else:
				value = None
			if value is None:
				raise KeyError("Attribute value undefined: %s" % repr(name))
			armap = self._armap()
			unusedName, encoder = armap[attr_name]
			if isinstance(value, list):
				value = ' '.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict.items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = ' '.join(sorted(lvalue))
			else:
				value = encoder(value)
			return value

	# def is_valid_name(self, value):
	# 	"""Returns True if a character string is a valid NAME

	# 	This test can be done standalone using the module function of
	# 	the same name (this implementation defaults to using that function).
	# 	By checking validity in the context of an element derived classes
	# 	may override this test.

	# 	This test is currently used only when checking IDs (see :meth:`set_id`)
	# 	"""
	# 	return is_valid_name(value)

	def is_empty(self):
		"""Whether this element *must* be empty.

		If the class defines the :attr:`GIFTCONTENT` attribute then the model
		is taken from there and this method returns True only if GIFTCONTENT is
		:attr:`ElementType.EMPTY`.

		Otherwise, the method defaults to False
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.EMPTY
		else:
			return False

	def is_mixed(self):
		"""Whether or not the element *may* contain mixed content.

		If the class defines the :attr:`GIFTCONTENT` attribute then the
		model is taken from there and this method returns True only if
		GIFTCONTENT is :attr:`ElementType.MIXED`.

		Otherwise, the method defaults to True
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.MIXED
		else:
			return True

	def get_children(self):
		"""Returns an iterable of the element's children.

		This method iterates through the internal list of children only.
		Derived classes with custom models (i.e., those that define
		attributes to customise child element creation) MUST override
		this method.

		Each child is either a character string or an instance of Element
		(or a derived class thereof).  We do not represent comments,
		processing instructions or other meta-markup.
		"""
		return iter(self._children)

	def attach_to_doc(self):
		pass

	def detach_from_doc(self):
		pass


class Document(Node):
	"""Base class for all GIFT documents.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L550

	With no arguments, a new Document is created with no base URI or root element.

	root
		If root is a class object (descended from :class:`Element`) it
		is used to create the root element of the document.

		If root is an orphan instance of :class:`Element` (i.e., it has no parent)
		it is used as the root element of the document and its
		:py:meth:`Element.attach_to_doc`
		method is called.

	base_uri
		See :meth:`set_base` for more information

	req_manager
		Sets the request manager object to use for future HTTP calls.
		Must be an instance of :class:`pyslet.http.client.Client`.
	"""

	def __init__(self, root=None):

		super().__init__()
		self.root = None
		"""The root element or None if no root element has been created yet.
		"""
		if root:
			if isinstance(root, Element):
				if root.parent:
					raise ValueError(
						"Element must be an orphan in Document constructor")
				self.root = root
				root.parent = self
				self.root.attach_to_doc(self)
			elif not issubclass(root, Element):
				raise ValueError
			else:
				self.root = root(self)
		self.idTable = {}

		def get_children(self):
			"""Yields the root element"""
			if self.root:
				yield self.root

		def __bytes__(self):
			"""Returns the GIFT document as a string"""
			pass
			"""
			s = io.BytesIO()
			self.write_txt(s, escape_char_data7)
			return s.getvalue()
			"""

		def __unicode__(self):
			"""Returns GIFT document as unicode string"""
			pass
			"""
			s = io.StringIO()
			for data in self.generate_txt(escape_char_data):
				s.write(data)
			return s.getvalue()
			"""

		def GIFTParser(self, entity):
			"""Creates a parser for this document

			https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L623

			entity
				The entity to parse the document from

			The default implementation creates an instance of :class:`GIFTParser`.

			This method allows some document classes to override the parser used to parse them.
			This method is only used when parsing existing document instances (see :py:meth:`read`
			for more information).

			Classes that override this method may still register themselves with
			:py:func:`register_doc_class` but if they do then the default :py:class:`GIFTParser` object
			will be used as automatic detection of document class is done by the parser itself
			based on the information in the prolog (and/or first element).
			"""
			from pyslet.gift.parser import GIFTParser
			return GIFTParser(entity)

			@classmethod
			def get_element_class(cls, name):
				"""Defaults to returning :class:`Element`.

				Derived classes override this method to enable the GIFT parser to create instances
				of custom classes based on the document context and element name.
				"""
				return Element

			def add_child(self, child_class, name=None):
				"""Creates the root element of the document.

				If there is already a root element it is detached from the document first using
				:py:meth:`Element.detach_from_doc`.

				Unlike :meth:`Element.add_child` there are no model customization options.  The
				root element is always found at :attr:`root`.
				"""
				if self.root:
					self.root.detach_from_doc()
					self.root.parent = None
					self.root = None
				child = child_class(self)
				if name:
					child.set_giftname(name)
				self.root = child
				return self.root

			def get_space(self):
				"""Returns the default space policy for the document.

				By default we return None, indicating that no policy is in force.
				Derived documents can override this behaviour to return either "preserve"
				or "default" to affect space handling.
				"""
				raise NotImplementedError

			def validation_error(self, msg, element, data=None, aname=None):
				"""Called when a validation error is triggered.

				msg
					contains a brief message suitable for describing the error
					in a log file.
				element
					the element in which the validation error occurred
					data, aname

				See :meth:`Element.validation_error`.

				Prior to raising :class:`GIFTValidityError` this method logs a
				suitable message at WARN level."""
				if aname:
					logging.warning("%s (in %s.%s) %s", msg, aname,
						"" if data is None else repr(data))
				else:
					logging.warning("%s (in %s) %s", msg, element.giftname,
						"" if data is None else repr(data))
				raise GIFTValidityError("%s (in %s)" % (msg, element.giftname))

			def read(self, src=None, **kws):
				"""Reads this document, parsing it from a source stream.

				With no arguments the document is read from the
				:py:attr:`base_uri` which must have been specified on
				construction or with a call to the :py:meth:`set_base` method.
				src (defaults to None)

				You can override the document's base URI by passing a value
				for *src* which may be an instance of :py:class:`GIFTEntity`
				or a file-like object suitable for passing to
				:meth:`read_from_stream`.
				"""
				if src:
					# Read from this stream, ignore base_uri
					if isinstance(src, GIFTEntity):
						self.read_from_entity(src)
					else:
						self.read_from_stream(src)
				else:
					with GIFTEntity() as e:
						self.read_from_entity(e)

			def read_from_stream(self, src):
				"""Reads this document from a stream

				src
					Any object that can be passed to :class:`GIFTEntity`'s
					constructor.
				"""
				self.data = []
				e = GIFTEntity()
				self.read_from_entity(e)

			def read_from_entity(self, e):
				"""Reads this document from an entity

				e
					A :class:`GIFTEntity` instance.

				The document is read from the current position in the entity.
				"""
				self.data = []
				parser = self.GIFTParser(e)
				parser.parse_document(self)

			def create(self, **kws):
				"""Creates the Document.

				Only documents with file type baseURIs are supported.
				"""
				pass

			def generate_gift(self):
				"""A generator that yields serialised XML

				Assume UTF-8 encoding.

				Yields character strings.
				"""
				if self.root:
					for s in self.root.generate_gift(root=True):
						yield s

			def write_gift(self, writer):
				"""Writes serialized GIFT to an output stream

				writer
					A file or file-like object operating in binary mode.

				The other arguments follow the same pattern as :meth:`generate_gift` which
				this method uses to create the output which is always UTF-8 encoded.
				"""
				for s in self.generate_gift():
					writer.write(s)

			def update(self, **kws):
				"""Updates the Document.

				Update outputs the document as a GIFT stream.
				The stream is written to the base_uri which must already exist.
				"""
				pass

			def diff_string(self, other_doc, before=10, after=5):
				"""Compares GIFT documents

				other_doc
					Another :class:`Document` instance to compare with.

				before (default 10)
					Number of lines before the first difference to output

				after (default 5)
					Number of lines after the first difference to output

				The two documents are converted to character strings and then
				compared line by line until a difference is found.  The result
				is suitable for logging or error reporting.  Used mainly to make the
				output of unittests easier to understand.
				"""
				pass


class GIFTEntity(MigratedClass):
	"""Represents a GIFT entity.

	Note: IGNORES URIs for now.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L3188

	This object serves two purposes: it acts as both the object used to store
	information about declared entities and also as a parser for feeding unicode
	characters to the main :py:class:`GIFTParser`.

	src
		May be a character string, or any object that supports
		file-like behaviour (seek and read).

		If provided, the corresponding open method is called immediately, see
		:meth:`open_string` and :meth:`open_file`.

	encoding
		If src is not None then this value will be passed when opening the entity
		reader.

	GIFTEntity objects act as context managers, hence it is possible to use::

		with GIFTEntity(src=URI.from_octets('mydata.txt')) as e:
			# process the entity here, will automatically close

	In Python 3.5 REPL:
	>>> import pyslet.rfc2396 as uri
	>>> uri.URI.from_octets('mygift.txt')
	<pyslet.rfc2396.URI object at 0x10225cfd0>
	"""
	def __init__(self, src=None, **kws):
		self.data_source = None
		self.char_source = None
		self.close_source = False
		self.the_char = None
		"""The character at the current position in the entity"""
		self.line_num = None
		"""The current line number within the entity (first line is line 1)"""
		self.line_pos = None
		"""The current character position within the entity (first char is 1)"""
		self.buff_text = ''
		self.base_pos = None

	chunk_size = io.DEFAULT_BUFFER_SIZE
	"""Characters are read from the data_source in chunks.
	The default chunk size is set from io.DEFAULT_BUFFER_SIZE, typically 8KB.
	"""

	def is_open(self):
		"""Returns True if the entity is open for reading."""
		return not (self.char_source is None)

	def open_unicode(self, src):
		"""Opens the entity from a unicode string."""
		self.data_source = None
		self.chunk = GIFTEntity.chunk_size
		self.char_source = io.StringIO(src)
		self.close_source = True
		self.base_pos = self.char_source.tell()
		self.reset()

	def open_file(self, src):
		"""Opens the entity from a file

		src
			An existing (open) binary file.
		"""
		self.data_source = src
		self.char_source = codecs.getreader('utf-8')(self.data_source)
		self.chunk = 1
		self.base_pos = self.char_source.tell()
		self.reset()

	def reset(self):
		"""Resets an open entity

		The entity returns to the first character in the entity."""
		if self.char_source is None:
			self.the_char = None
			self.base_pos = None
		else:
			self.char_source.seek(self.base_pos)
			self.the_char = ''
		self.line_num = 1
		self.line_pos = 0
		self.chars = ''
		self.char_seek = self.base_pos
		self.char_pos = -1
		self.ignore_lf = False
		self.next_char()

	def get_position_str(self):
		"""A short string describing the current position.

		For example, if the current character is pointing to character 6 of line 4
		then it will return the string 'Line 4.6'
		"""
		return "Line %i.%i" % (self.line_num, self.line_pos)

	def next_char(self):
		"""Advances to the next character in an open entity.

		This method takes care of the End-of-Line handling rules which force us to
		remove any CR characters and replace them with LF if they appear no their own or
		to silently drop them if they appear as part of a CR-LEF combination.
		"""
		if self.the_char is None:
			return
		self.char_pos = self.char_pos + 1
		self.line_pos = self.line_pos + 1
		if self.char_pos >= len(self.chars):
			self.char_seek = self.char_source.tell()
			self.chars = self.char_source.read(self.chunk)
			self.char_pos = 0
		if self.char_pos >= len(self.chars):
			self.the_char = None
		else:
			self.the_char = self.chars[self.char_pos]
			if self.the_char == '\x0D':
				# change to a line feed and ignore the next line feed
				self.the_char = '\x0A'
				self.ignore_lf = True
				self.next_line()
			elif self.the_char == '\x0A':
				if self.ignore_lf:
					self.ignore_lf = False
					self.next_char()
				else:
					self.next_line()
			else:
				self.ignore_lf = False

	# magic_table = {}

	def next_line(self):
		"""Called when the entity reader detects a new line.

		This method increases the internal line count and resets the
		character position to the beginning of the line.  You will not
		normally need to call this directly as line handling is done
		automatically by :py:meth:`next_char`.
		"""
		self.line_num = self.line_num + 1
		self.line_pos = 0

	def close(self):
		"""Closes the entity."""
		if self.close_source:
			if self.char_source is not None:
				self.char_source.close()
				self.char_source = None
			if self.data_source is not None:
				self.data_source.close()
				self.data_source = None
			self.close_source = False
		self.the_char = None
		self.line_num = None
		self.line_pos = None

	def __enter__(self):
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		self.close()
