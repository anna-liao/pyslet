#! /usr/bin/env

import io
import os
import os.path
import codecs
import logging
import random
import warnings

import logging
# logging.basicConfig(level=logging.DEBUG)

from copy import copy
from ..py2 import force_text
from .py3 import (
    PY2,
	# is_text,
	dict_items,
	join_characters,
	uspace,
	uempty,
	dict_keys,
	character)
from .. import rfc2396 as uri
from types import MethodType


class GIFTError(Exception):
	"""Base class for all exceptions raised by this module."""
	pass


class GIFTUnsupportedChildTypeError(GIFTError):
	"""Raised by :meth:`Element.generate_gift`

	Indicates that generate_gift encountered unsupported child type.

	Supported types: question, questionTitle, correctResponse, wrongResponse
	"""
	pass

class DuplicateGIFTNAME(GIFTError):
	"""Raised by :py:func:`map_class_elements`

	Indicates an attempt to declare two classes with same GIFT name.
	"""
	pass


class GIFTAttributeSetter(GIFTError):
	"""Raised when a badly formed attribute mapping is found."""
	pass


class GIFTMissingResourceError(GIFTError):
	"""Raised when an entity cannot be found (e.g., missing file)"""
	pass


class GIFTMissingLocationError(GIFTError):
	"""Raised when on create, read, or update when base_uri is None"""
	pass


class GIFTMixedContentError(GIFTError):
	"""Raised by :meth:`Element.get_value`

	Indicates unexpected element children."""
	pass


class GIFTParentError(GIFTError):
	"""Raised by :meth:`Element.attach_to_parent`

	Indicates that the element was not an orphan."""
	pass


class GIFTUnsupportedSchemeError(GIFTError):
	""":attr:`Document.base_uri` has an unsupported scheme

	Currently only file schemes are supported for open operations.
	For create and update operations, only file types are supported
	"""
	pass


class GIFTValidityError(GIFTError):
	"""Base class for all validation errors.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L105

	Raised when a document or content model violates a validity
	constraint.  These errors can be generated by the parser (for
	example, when validating a document against a declared DTD) or by
	Elements themselves when content is encountered that does not fit
	content model expected.
	"""
	pass


class GIFTIDClashError(GIFTValidityError):
	"""A validity error caused by two elements with the same ID"""
	pass


class GIFTIDValueError(GIFTValidityError):
	"""A validity error caused by an element with an invalid ID

	ID attribute must satisfy the production for NAME."""
	pass


class GIFTUnknownChild(GIFTError):
	"""Raised by :meth:`Element.remove_child`

	Indicates that the child being removed was not found in the
	element's content."""
	pass


def is_s(c):
	"""Tests production [3] S

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L143

	Optimized for speed as this function is called a lot by the parser.

	Checked in Python 3.5 interpreter
	>>> c = ' '
	>>> c in "\x20\x09\x0A\x0D"
	True
	"""
	return c is not None and c in "\x20\x09\x0A\x0D"


def collapse_space(data, smode=True, stest=is_s):
	"""Returns data with all spaces collapsed to a single space.

	smode
		Determines the fate of any leading space, by default it is
		True and leading spaces are ignored provided the string has
		some non-space characters.

	stest
		You can override the test of what constitutes a space by
		passing a function for stest, by default we use :func:`is_s`
		and any value passed to stest should behave similarly.

	Note on degenerate case: this function is intended to be called with
	non-empty strings and will never *return* an empty string.  If there
	is no data then a single space is returned (regardless of smode).
	"""
	result = []
	for c in data:
		if stest(c):
			if not smode:
				result.append(uspace)
			smode = True
		else:
			smode = False
			result.append(c)
	if result:
		return ''.join(result)
	else:
		return uspace

"""
Variable definitions and functions below are for unicode and py2.
"""

name_start_char = (
	':', ('A', 'Z'), '_', ('a', 'z'), (character(0xc0), character(0xd6)),
	(character(0xd8), character(0xf6)), (character(0xf8), character(0x02ff)),
	(character(0x0370), character(0x037d)),
	(character(0x037f), character(0x1fff)),
	(character(0x200c), character(0x200d)),
	(character(0x2070), character(0x218f)),
	(character(0x2c00), character(0x2fef)),
	(character(0x3001), character(0xd7ff)),
	(character(0xf900), character(0xfdcf)),
	(character(0xfdf0), character(0xfffd)))


def is_name_start_char(c):
	return name_start_char.test(c)

# is_name_start_char = name_start_char.test  # noqa (def used by decorator)

name_char = (name_start_char, '-', '.', ('0', '9'), character(0xb7),
	(character(0x0300), character(0x036f)),
	(character(0x203f), character(0x2040)))


def is_name_char(c):
	return name_char.test(c)


def is_valid_name(name):
	# Tests if name is a string matching production [5] Name
	if name:
		if not is_name_start_char(name[0]):
			return False
		for c in name[1:]:
			if not is_name_char(c):
				return False
		return True
	else:
		return False


def escape_char_data(src, quote=False):
	"""Returns a string with GIFT reserved characters escaped.

	We also escape return characters to prevent them being ignored.
	If quote is True then the string is returned as a quoted attribute value.

	GIFT Special Characters: https://docs.moodle.org/23/en/GIFT_format#Special_Characters_.7E_.3D_.23_.7B_.7D
	Put backslash (\) before a control character
	"""
	data = []
	# apos = 0
	# quot = 0
	for c in src:
		if c == '~':
			data.append('\~')
		elif c == '=':
			data.append('\=')
		elif c == '#':
			data.append('\#')
		elif c == '{':
			data.append('\{')
		elif c == '}':
			data.append('\}')
		else:
			data.append(c)
	return ''.join(data)


class ElementType(object):
	"""Represents element type definitions.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1171

	"""
	#: Content type constant for EMPTY
	EMPTY = 0
	Empty = 0

	#: Content type constant for ANY
	ANY = 1
	Any = 1

	#: Content type constant for mixed content
	MIXED = 2
	Mixed = 2

	#: Content type constant for element content
	ELEMENT_CONTENT = 3
	ElementContent = 3

	def __init__(self):
		#: The entity in which this element was declared
		self.entity = None
		#: The name of this element
		self.name = None
		self.content_type = ElementType.EMPTY
		"""The content type of this element, one of the constants defined above."""
		self.content_model = None
		"""A :py:class:`GIFTContentParticle` instance which contains the element's
		content model or None in the case of EMPTY or ANY declarations."""
		self.particle_map = None
		"""A mapping used to validate the content model during parsing.  It maps the
		name of the first child element found to a list of :py:class:`GIFTNameParticle`
		instances that can represent it in the content model.  For more information
		see :py:attr:`GIFTNameParticle.particle_map`."""

	def build_model(self):
		"""Builds internal structures to support model validation."""
		if self.content_type == self.ELEMENT_CONTENT:
			self.particle_map = {}
			if not self.content_model.seek_particles(self.particle_map):
				# the entire content model is optional so add ETag mapping
				self.particle_map[''] = None
			exit_particles = {'': None}
			self.content_model.build_particle_maps(exit_particles)
		elif self.content_type == self.MIXED:
			self.particle_map = {}
			self.content_model.seek_particles(self.particle_map)
			self.particle_map[''] = None
			# always optional repeatable
			self.content_model.build_particle_maps(self.particle_map)

	def is_deterministic(self):
		"""Tests if the content model is deterministic.

		For degenerate cases (elements declared with ANY or EMPTY) the method
		always returns True."""
		if self.content_type == self.ELEMENT_CONTENT or \
				self.content_type == self.MIXED:
			return self.content_model.is_deterministic(self.particle_map)
		else:
			return True

_gift_base = 'gift:base'


class Node(object):
	"""Base class for Element and Document shared attributes.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L377

	GIFT documents are defined hierarchically, each element has a parent which
	is either another element or a GIFT document.
	"""
	def __init__(self, parent=None):
		self.parent = parent
		super(Node, self).__init__()
		"""The parent of this element, for GIFT documents this attribute is
		used as a sentinel to simplify traversal of the hierarchy and is set
		to None."""

	def __str__(self):
		raise NotImplementedError

	def get_children(self):
		"""Returns an iterator over this object's children."""
		raise NotImplementedError

	@classmethod
	def get_element_class(cls, name):
		"""Returns a class object for representing an element

		name
			a unicode string representing the element name.

		The default implementation returns None - for elements this has
		the effect of deferring the call to the parent document (where
		this method is overridden to return :py:class:`Element`).

		This method is called immediately prior to :py:meth:`add_child`
		and (when applicable) :py:meth:`get_child_class`.

		The real purpose of this method is to allow an element class to
		directly control the way the name of a child element maps to the
		class used to represent it.  You would normally override this
		method in the :py:class:`Document` to map element names to
		classes but in some cases you may want to tweek the mapping at
		the individual element level.  For example, if the same element
		name is used for two different purposes in the same XML
		document.  Although confusing, this is allowed in XML schema."""
		return None

	def add_child(self, child_class, name=None):
		raise NotImplementedError

	def get_base(self):
		raise NotImplementedError

	def set_base(self, base):
		raise NotImplementedError

	def get_lang(self):
		raise NotImplementedError

	def set_lang(self):
		raise NotImplementedError

	def get_space(self):
		# raise NotImplementedError
		return None


GIFTEmpty = ElementType.EMPTY
GIFTMixedContent = ElementType.MIXED
ElementContent = ElementType.ELEMENT_CONTENT


class Element(Node):
	"""Base class that represents all GIFT elements.
	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L1247

	This class is usually used only as a default to represent elements
	with unknown content models or that require no special processing.
	The power of Pyslet's GIFT package comes when different classes are
	derived from this one to represent the different (classes of)
	elements defined by an application.  These derived classes will
	normally some form of custom serialisation behaviour (see below).

	Although derived classes are free to implement a wide range of
	python protocols they *must* always return True in truth tests.
	This ensures that derived classes are free to implement
	__len__ but bear in mind that an instance of a derived class for
	which __len__ returns 0 *must* still evaluate to True.

	Elements compare equal if their names, attribute lists and canonical
	children all compare equal.  No rich comparison methods are provided.

	In addition to truth testing, custom attribute serialisation
	requires a custom implementation of __getattr__, see below for more
	details.

	Elements are usually constructed by calling the parent element's (or
	document's) :meth:`Node.add_child` method.  When constructed
	directly, the constructor requires that the parent :class:`Node` be
	passed as an argument.  If you pass None then an orphan element is
	created (see :meth:`attach_to_parent`).

	Some aspects of the element's GIFT serialisation behaviour are controlled
	by special class attributes that can be set on derived classes.

	GIFTNAME
		The default name of the element the class represents.

	GIFTCONTENT
		The default content model of the element; one of the :py:class:`ElementType`
		constants.

	You can customise attribute mappings using the following special class attributes.

	ID
		The name of the ID attribute if the element has a unique ID.
		With this class attribute set, ID handling is automatic (see :py:meth:`set_id`
		and py:attr:`id` below).

	By default, attributes are simply stored as name/value character strings in an
	internal dictionary.  It is often more useful to map GIFT attributes directly onto
	similarly named attributes of the instances that represent each element.

	This mapping can be provided using class attributes of the form GIFTATTR_aname where
	/aname/ is the name of the attribute as it would appear in the element's tag.  There
	are a number of forms of attribute mapping.

	GIFTATTR_aname=<string>

		This form creates a simple mapping from the GIFT attribute 'aname' to a python
		attribute with a defined name.  For example, you might want to create a mapping
		like this to avoid a python reserved word::

				GIFTATTR_class="style_class"

		This allows GIFT elements like this::

				// text

		To be parsed into python objects that behave like this::

				element.style_class=="text"    # True

		If an instance is missing a python attribute corresponding to a defined GIFT
		attribute, or its value has been set to None, then the GIFT attribute is omitted
		from the element's tag when generating GIFT output.

	GIFTATTR_aname=(<string>, decode_function, encode_function)

		More complex attributes can be handled by setting GIFTATTR_aname to a tuple.
		The first item is the python attribute name (as above); the *decode_function* is a
		simple callable that takes a string argument and returns the decoded value of the
		attribute and the *encode_function* preforms the reverse transformation.

		The encode/decode functions can be None to indicate a no-operation.

		For example, you might want to create an integer attribute using something like::

				// source GIFT
				::Q1::

				# class attribute definition
				XMLATTR_title = ('Q1', str, str)

				# the resulting object behaves like this...
				element.title == 'Q1'    # True

	GIFTATTR_aname=(<string>, decode_function, encode_function, type)

		When GIFT attribute values are parsed from tags the option *type*
		component of the tuple descriptor can be used to indicate a multi-valued
		attribute.  For example, you might want to use a multi-valued mapping for
		GIFT attributes defined using one of the plural forms, IDREFS, ENTITIES, and
		NMTOKENS.

		If the *type* value is not None then the GIFT attribute value is first split
		by white-space, as per the GIFT specification, and then the decode function
		is applied to each resulting component.  The instance attribute is then set
		depending on the value of the *type*:

		list
			The instance attribute becomes a list, for example::

			// source GIFT
			{ =yellow # right; good! ~red # wrong, it's yellow ~blue # wrong, it's yellow}

			# class attribute definition
			XMLATTR_response = ('response', str, str, list)

			# resulting object behaves like this...
			element.response == ['=yellow', '#', 'right;', 'good!', '~red', '#', 'wrong,',
								'it's', 'yellow', '~blue', '#', 'wrong,', 'it's', 'yellow']

		NOTE: ignoring dictionary mapping for now.

		When serialising to GIFT the reverse transformations are performed using the encode
		functions and the type (plain or list) of the attribute's *current* value.  The declared
		multi-valued type is ignored.  For dictionary values the order of the output values may
		not be the same as the order originally read from the GIFT input.

		Warning: Empty lists result in GIFT attribute values that are present but with empty strings.
		If you wish to omit these attributes in the output GIFT you must set the attribute value to None.

	Some element specifications define large numbers of optional attributes and it is inconvenient to write
	constructors to initialise these members in each instance and possibly wasteful of memory if a document
	contains large numbers of such elements.

	To obviate the need for optional attributes to be present in every instance an implementation of
	__getattr__ is provided that will ensure that element.aname returns None if 'aname' is the target of
	an attribute mapping rule, regardless of whether or not the attribute has actually been set for the
	instance.

		Implementation note: internally, the GIFTATTR_* descriptors are parsed into two mappings the first
		time they are needed.  The forward map maps GIFT attribute names onto tuples of:

			(<python attribute name>, decode_function, type)

		The reverse map maps python attribute names onto a tuple of:

			(<gift attribute name>, encode_function)

	GIFT attribute names may contain characters that are not legal in Python syntax but automated attribute
	processing is still supported for these attributes even though the declaration cannot be written into
	the class definition.  Use the builtin function setattr immediately after the class is defined, for
	example::

		class MyElement(Element):
			pass

		setattr(MyElement, 'GIFTATTR_hyphen-attr', 'hyphen_attr')
	"""
	GIFTCONTENT = ElementType.MIXED

	def __init__(self, parent, name=None):
		super(Element, self).__init__(parent)
		if name is None:
			if hasattr(self.__class__, 'GIFTNAME'):
				self.set_giftname(self.GIFTNAME)
			else:
				self.set_giftname(None)
		else:
			warnings.warn(
				"Element: passing name to constructor is deprecated (%s);"
				"use set_giftname instead" % name)
			import traceback
			traceback.print_stack()
			self.giftname = name
		self.id = None
		self._attrs = {}
		self._children = []

	def __bool__(self):
		# All elements are considered non-zero; we implement this to
		# reduce spurious calls to __getattr__
		return True

	__nonzero__ = __bool__

	def set_giftname(self, name):
		"""Sets the name of this element

		name
			A character string.

		You will not normally need to call this method, it is called
		automatically during child creation.

		"""
		self.giftname = name

	def get_giftname(self):
		"""Returns the name of this element

		In the default implementation this is a simple character string.
		"""
		return self.giftname

	def get_document(self):
		"""Returns the document that contains the element.

		If the element is an orphan, or is the descendant of an orphan
		then None is returned."""
		if self.parent:
			if isinstance(self.parent, Document):
				return self.parent
			else:
				return self.parent.get_document()
		else:
			return None

	def set_id(self, id):
		"""Sets the id of the element

		The change is registered with the enclosing document.  If the id
		is already taken then :class:`GIFTIDClashError is raised.
		"""
		if not self.is_valid_name(id):
			raise GIFTIDValueError(id)
		doc = self.get_document()
		if doc:
			doc.unregister_element(self)
			self.id = id
			doc.register_element(self)
		else:
			self.id = id

	@classmethod
	def mangle_aname(cls, name):
		"""Returns a mangled attribute name

		A mangled attribute name is simple name prefixed with "GIFTATTR\_".
		"""
		return "GIFTATTR_" + name

	@classmethod
	def unmangle_aname(cls, mname):
		"""Returns an unmangled attribute name.

		If mname is not a mangled name, None is returned.  A mangled attribute
		name starts with "GIFTATTR\_".
		"""
		if mname.startswith('GIFTATTR_'):
			return mname[9:]
		else:
			return None

	@classmethod
	def _remap(cls):
		def nop(arg):
			return arg

		amap = {}
		armap = {}
		for mname in dir(cls):
			name = cls.unmangle_aname(mname)
			if name:
				setter = getattr(cls, mname)
				# if is_text(setter):
				if isinstance(setter, str):
					# use simple attribute assignment
					attr_name, encoder, decoder, vtype = \
						setter, None, None, None
				elif isinstance(setter, tuple):
					if len(setter) == 3:
						attr_name, decoder, encoder = setter
						vtype = None
					elif len(setter) == 4:
						attr_name, decoder, encoder, vtype = setter
					else:
						raise GIFTAttributeSetter(
							"bad GIFTATTR_ definition: %s attribute of %s" %
							(name, cls.__name__))
				else:
					raise GIFTAttributeSetter(
						"setting %s attribute of %s" %
						(name, cls.__name__))
				if encoder is None:
					encoder = nop
				if decoder is None:
					decoder = nop
				if vtype not in (list, dict, None):
					raise GIFTAttributeSetter(
						"Legacy GIFTATTR_ definition: %s attribute of %s" %
						(name, cls.__name__))
				amap[name] = (attr_name, decoder, vtype)
				armap[attr_name] = (name, encoder)
		setattr(cls, "_gift_amap", amap)
		setattr(cls, "_gift_armap", armap)

	@classmethod
	def _armap(cls):
		if "_gift_armap" not in cls.__dict__:
			cls._remap()
		return cls._gift_armap

	@classmethod
	def _amap(cls):
		if "_gift_amap" not in cls.__dict__:
			cls._remap()
		return cls._gift_amap

	def __getattr__(self, name):
		if name in self._armap():
			return None
		else:
			raise AttributeError(name)

	def get_attributes(self):
		"""Returns a dict mapping attribute names onto values.

		Each attribute value is represented as a character string.
		Derived classes MUST override this method if they define any
		custom attribute mappings.

		The dictionary returned represents a copy of the information
		in the element and so may be modified by the caller.
		"""
		attrs = copy(self._attrs)
		if self.id:
			attrs[self.__class__.ID] = self.id
		armap = self._armap()
		for attr_name, desc in dict_items(armap):
			name, encoder = desc
			value = getattr(self, attr_name, None)
			if isinstance(value, list):
				value = uspace.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict_items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = uspace.join(sorted(lvalue))
			elif value is not None:
				value = encoder(value)
			if value is not None:
				attrs[name] = value
		return attrs

	def set_attribute(self, name, value):
		"""Sets the value of an attribute.

		name
			The name of the attribute to set

		value
			The value of the attribute (as a character string) or None
			to remove the attribute.
		"""
		amap = self._amap()
		if name in amap:
			attr_name, decoder, vType = amap[name]
			if vType is list:
				if value is None:
					value = []
				else:
					value = value.split()
				setattr(self, attr_name, [decoder(v) for v in value])
			elif vType is dict:
				if value is None:
					value = []
				else:
					value = value.split()
				dvalue = {}
				for iv in (decoder(v) for v in value):
					dvalue[iv] = dvalue.get(iv, 0) + 1
				setattr(self, attr_name, dvalue)
			else:
				x = getattr(self, attr_name, None)
				if type(x) in (list, dict):
					logging.error(
						"Problem setting %s in %s: single value will overwrite"
						" List or Dict", name, self.__class__.__name__)
				if value is None:
					setattr(self, attr_name, None)
				else:
					setattr(self, attr_name, decoder(value))
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			self.set_id(value)
		else:
			if value is None:
				if name in self._attrs:
					del self._attrs[name]
			else:
				self._attrs[name] = value

	def get_attribute(self, name):
		"""Gets the value of a single attribute as a string.

		If the element has not attribute with *name* then KeyError is raised.

		This method searches the attribute mappings and will return attribute values obtained by
		encoding the associated objects according to the mapping.
		"""
		if name in self._attrs:
			return self._attrs[name]
		elif hasattr(self.__class__, 'ID') and name == self.__class__.ID:
			return self.id
		else:
			amap = self._amap()
			if name in amap:
				attr_name, decoder, vType = amap[name]
				value = getattr(self, attr_name, None)
			else:
				value = None
			if value is None:
				raise KeyError("Attribute value undefined: %s" % repr(name))
			armap = self._armap()
			unusedName, encoder = armap[attr_name]
			if isinstance(value, list):
				value = uspace.join(encoder(v) for v in value)
			elif isinstance(value, dict):
				lvalue = []
				for key, freq in dict_items(value):
					lvalue = lvalue + [encoder(key)] * freq
				value = uspace.join(sorted(lvalue))
			else:
				value = encoder(value)
			return value

	def is_valid_name(self, value):
		"""Returns True if a character string is a valid NAME

		This test can be done standalone using the module function of
		the same name (this implementation defaults to using that function).
		By checking validity in the context of an element derived classes
		may override this test.

		This test is currently used only when checking IDs (see :meth:`set_id`)
		"""
		return is_valid_name(value)

	def is_empty(self):
		"""Whether this element *must* be empty.

		If the class defines the :attr:`GIFTCONTENT` attribute then the model
		is taken from there and this method returns True only if GIFTCONTENT is
		:attr:`ElementType.EMPTY`.

		Otherwise, the method defaults to False
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.EMPTY
		else:
			return False

	def is_mixed(self):
		"""Whether or not the element *may* contain mixed content.

		If the class defines the :attr:`GIFTCONTENT` attribute then the
		model is taken from there and this method returns True only if
		GIFTCONTENT is :attr:`ElementType.MIXED`.

		Otherwise, the method defaults to True
		"""
		if hasattr(self.__class__, 'GIFTCONTENT'):
			return self.__class__.GIFTCONTENT == ElementType.MIXED
		else:
			return True

	def get_children(self):
		"""Returns an iterable of the element's children.

		This method iterates through the internal list of children only.
		Derived classes with custom models (i.e., those that define
		attributes to customise child element creation) MUST override
		this method.

		Each child is either a character string or an instance of Element
		(or a derived class thereof).  We do not represent comments,
		processing instructions or other meta-markup.
		"""
		return iter(self._children)

	def get_canonical_children(self):
		"""Returns children with canonical white space

		A wrapper for :py:meth:`get_children` that returns at iterable of the element's
		children canonicalized for white space as follows.  We check the current setting
		of gift:space, returning the same list of children as :py:meth:`get_children` if
		'preserve' is in force.  Otherwise we remove any leading space and collapse all
		all others to a single space character.
		"""
		children = self.get_children()
		# If there are no children there is nothing to do, so we don't catch StopIteration
		try:
			first_child = next(children)
		except StopIteration:
			return
		e = self
		while isinstance(e, Element):
			# spc = e.get_space()
			# if spc is not None:
			# 	if spc == 'preserve':
			# 		yield first_child
			# 		try:
			# 			while True:
			# 				yield next(children)
			# 			# will raise StopIteration and terminate method
			# 		except StopIteration:
			# 			return
			# 	else:
			# 		break
			e = e.parent
		try:
			ichild = next(children)
		except StopIteration:
			# There was only one child
			if isinstance(first_child, str):
				first_child = collapse_space(first_child)
			yield first_child
			return
		# Collapse strings to a single string entry and collapse spaces
		data = []
		if isinstance(first_child, str):
			data.append(first_child)
			smode = True
		else:
			smode = False
			yield first_child
		while True:
			if isinstance(ichild, str):
				data.append(ichild)
			else:
				if data:
					data_child = collapse_space(''.join(data), smode)
					if not smode or data_child != uspace:
						# ignore a leading space completely
						yield data_child
					data = []
				yield ichild
				smode = False
			try:
				ichild = next(children)
				continue
			except StopIteration:
				if data:
					data_child = collapse_space(''.join(data), smode)
					if data_child == uspace:
						# just white space, return empty string if we're the
						# only child for consistency
						if smode:
							yield uempty
						else:
							# strip the whole last child
							return
					elif data_child[-1] == uspace:
						# strip the trailing space from the last child
						data_child = data_child[:-1]
					yield data_child
				return

	def _find_factory(self, child_class):
		if hasattr(self, child_class.__name__):
			return child_class.__name__
		else:
			for parent in child_class.__bases__:
				fname = self._find_factory(parent)
				if fname:
					return fname
			return None

	def get_or_add_child(self, child_class):
		"""Returns the first child of type child_class

		If there is no child of that class then a new child is added.
		"""
		children = self.find_children_depth_first(child_class, max_depth=1)
		try:
			return children.next()
		except StopIteration:
			return self.add_child(child_class)

	def add_child(self, child_class, name=None):
		"""Adds a new child of the given class attached to this element.

		child_class
			A class object (or callable) used to create a new instance.

		name
			The name given to the element (by the caller).  If no name is given
			then the default name for the child is used.  When the child returned
			is an existing instance, name is ignored.

		By default, an instance of child_class is created and attached
		to the internal list of child elements.

		Child creation can be customised to support a more natural
		mapping for structured elements as follows.  Firstly, the name
		of child_class (*not* the element name) is looked up in the
		parent (self), if there is no match, the method resolution order
		is followed for *child_class* looking up the names of each base
		in turn until a matching attribute is found.  If there are no
		matches then the default handling is performed.

		Otherwise, the behaviour is determined by the matching attribute
		as follows.

		1   If the attribute is None then a new instance of child_class
			is created and assigned to the attribute.
		2   If the attribute is a list then a new instance of child_class
			is created and appended to the attribute's value.
		3   Finally, if the attribute value is already an instance of
			child_class it is returned unchanged.
		4   Deprecated: A method attribute is called either without
			arguments (if the method name matches the child_class
			exactly) or with the child_class itself passed as an
			argument.  It must return the new child element.

		In summary, a new child is created and attached to the element's
		model *unless* the model supports a single element of the given
		child_class and the element already exists (as evidenced by an
		attribute with the name of child_class or one of its bases), in
		which case the existing instance is returned.
		"""
		if self.is_empty():
			self.validation_error("Unexpected child element", name)
		child = None
		factory_name = self._find_factory(child_class)
		try:
			if factory_name:
				factory = getattr(self, factory_name)
				if isinstance(factory, MethodType):
					warnings.warn(
						"%s.%s method-based content model is deprecated" %
						(type(self).__name__, factory_name),
						DeprecationWarning, stacklevel=3)
					if factory_name != child_class.__name__:
						child = factory(child_class)
					else:
						child = factory()
				elif factory is None:
					child = child_class(self)
					setattr(self, factory_name, child)
				elif isinstance(factory, list):
					child = child_class(self)
					factory.append(child)
				elif isinstance(factory, child_class):
					child = factory
					child.reset(True)
				else:
					raise TypeError(
						factory_name, repr(factory), repr(child_class))
				if child is not None:
					if name:
						child.set_giftname(name)
					return child
			# else fall through to the default processing...
			child = child_class(self)
			self._children.append(child)
			if name:
				child.set_giftname(name)
			return child
		except TypeError as e:
			import traceback
			logging.error("Error creating GIFT element: %s", e)
			traceback.print_exc()
			raise TypeError("Can't create %s in %s" %
				(child_class.__name__, self.__class__.__name__))

	def remove_child(self, child):
		"""Removes a child from this element's children.

		child
			A :class:`Element` instance that must be a direct child.
			That is, one that would be yielded by :meth:`get_children`.

		By default, we search the internal list of child elements.

		For content model customisation we follow the same name matching
		conventions as for child creation (see :meth:`add_child`).  If a
		matching attribute is found then we process them as follows:

		1. If the attribute's value is *child* then it is set to None,
		if it is not *child* then :class:`GIFTUnknownChild` is raised.

		2. If the attribute is a list then we remove *child* from the list.
		If *child* is not in the list :class:`GIFTUnknownChild` is raised.

		3. If the attribute is None then we raise :class:`GIFTUnknownChild`.
		"""
		if self.is_empty():
			raise GIFTUnknownChild(child.giftname)
		factory_name = self._find_factory(child.__class__)
		if factory_name:
			factory = getattr(self, factory_name)
			if factory is None:
				raise GIFTUnknownChild(child.giftname)
			elif isinstance(factory, list):
				match = False
				for i in range(len(factory)):
					if factory[i] is child:
						child.detach_from_doc()
						child.parent = None
						del factory[i]
						match = True
						break
				if not match:
					raise GIFTUnknownChild(child.giftname)
			elif factory is child:
				# Single allowable child is replaced with None
				child.detach_from_doc()
				child.parent = None
				setattr(self, factory_name, None)
			else:
				raise TypeError("%s.%s in Element.remove_child" %
					(type(self).__name__, factory_name))
		else:
			match = False
			for i in range(len(self._children)):
				if self._children[i] is child:
					child.detach_from_doc()
					child.parent = None
					del self._children[i]
					match = True
					break
			if not match:
				raise GIFTUnknownChild(child.giftname)

	def find_children(self, child_class, child_list, max=None):
		"""Finds children of a given class"""
		warnings.warn(
			"Element.find_children is deprecated, use "
			"find_children_depth_first instead", DeprecationWarning,
			stacklevel=3)

	def find_children_breadth_first(self, child_class, sub_match=True,
		max_depth=1000, **kws):
		"""Generates all children of a given class"""
		raise NotImplementedError

	def find_children_depth_first(self, child_class, sub_match=True,
		max_depth=1000, **kws):
		"""Generates all children of a given class"""
		raise NotImplementedError

	def find_parent(self, parent_class):
		"""Finds the first parent of the given class.

		Traverses the hierarchy through parent elements until a matching
		parent is found or returns None.
		"""
		parent = self.parent
		while parent and not isinstance(parent, parent_class):
			if isinstance(parent, Element):
				parent = parent.parent
			else:
				parent = None
		return parent

	def attach_to_parent(self, parent):
		"""Called to attach an orphan element to a parent.

		This method is not normally needed, when creating GIFT elements you would
		normally call :meth:`add_child` on the parent which ensures that elements
		are create in the context of a parent node. The purpose of this method is
		to allow orphaned elements to be associated with a (new) parent.  For example,
		after being detached from one element hierarchy and attached to another.

		This method does not do any special handling of child elements, the caller takes
		responsibility for ensuring that this element will be returned by future calls
		to parent.get_children().  However, :py:meth:`attach_to_doc` is called to ensure
		id registrations are made.
		"""
		if self.parent:
			raise GIFTParentError("Expected orphan")
		self.parent = parent
		self.attach_to_doc()

	def attach_to_doc(self, doc=None):
		"""Called when the element is first attached to a document.

		This method is not normally needed.  When creating GIFT elements
		you would normally call :meth:`add_child` on the parent which ensures
		that elements are created in the context of a containing document.
		The purpose of this method is to allow orphaned elements to be
		associated with a parent (document) after creation.  For example,
		after being detached from one element hierarchy and attached to another
		(possibly in a different document).

		The default implementation ensures that any ID attributes belonging
		to this element or its descendents are registered.
		"""
		if doc is None:
			doc = self.get_document()
		if doc:
			if self.id:
				doc.register_element(self)
			for child in self.get_children():
				if isinstance(child, Element):
					child.attach_to_doc(doc)

	def detach_from_parent(self):
		"""Called to detach an element from its parent

		The result is that this element becomes an orphan.

		This method does not do any special handling of child elements,
		the caller takes responsibility for ensuring that this element
		will no longer be returned by future calls to the (former) parent's
		:meth:`get_children` method.

		We do call :py:meth:`detach_from_doc` to ensure id registrations
		are removed and :attr:`parent` is set to None.
		"""
		self.detach_from_doc()
		self.parent = None

	def detach_from_doc(self, doc=None):
		"""Called when an element is being detached from a document.

		doc
			The document the element is being detached from, if None
			then this is determined automatically.  Provided as an optimisation
			for speed when detaching large parts of the element hierarchy.

		The default implementation ensures that any ID attributes belonging
		to this element or its descendants are unregistered.
		"""
		if doc is None:
			doc = self.get_document()
		if doc:
			if self.id:
				doc.unregister_element(self)
			for child in self.get_children():
				if isinstance(child, Element):
					child.detach_from_doc(doc)

	def add_data(self, data):
		"""Adds a character string to this element's children.

		This method raises a validation error if the element cannot take
		data children."""
		data = str(data)
		if self.is_mixed():
			if self._children and isinstance(self._children[-1], str):
				# To ease the comparison function we collapse string children
				self._children[-1] = self._children[-1] + data
			else:
				self._children.append(data)
		else:
			ws = True
			for c in data:
				if not is_s(c):
					ws = False
					break
			if not ws:
				self.validation_error("Unexpected data", data)

	def content_changed(self):
		"""Notifies an element that its content has changed.

		Called by the parser once the element's attribute values and
		content have been parsed from the source.  Can be used to trigger
		any internal validation required following manual changes to the
		element.

		The default implementation tidies up the list of children reducing
		runs of data to a single string to make future operations simpler
		and faster.
		"""
		new_children = []
		data_children = []
		for child in self._children:
			if isinstance(child, str):
				data_children.append(child)
			elif len(data_children) == 1:
				new_children.append(data_children[0])
				new_children.append(child)
				data_children = []
			elif len(data_children) > 1:
				new_children.append(''.join(data_children))
				new_children.append(child)
				data_children = []
			else:
				new_children.append(child)
		if len(data_children) == 1:
			new_children.append(data_children[0])
		elif len(data_children) > 1:
			new_children.append(''.join(data_children))
		self._children = new_children

	def generate_value(self, ignore_elements=False):
		"""Generate strings representing the element's content

		A companion method to :meth:`get_value` which is useful
		when handling elements that contain a large amount of data).
		For more information see :py:meth:`get_value`.
		"""
		if not self.is_mixed():
			raise GIFTMixedContentError(self.__class__.__name__)
		for child in self.get_children():
			if isinstance(child, Element):
				name = child.giftname
			else:
				name = child
			logging.debug("generate_value(): child name, %s\n" % name)
			yield str(child)
			# if isinstance(child, str):
			# 	yield str(child)
			# elif not ignore_elements:
			# 	raise GIFTMixedContentError(str(self))

	def get_value(self, ignore_elements=False):
		"""Returns a single object representing the element's content.

		ignore_elements
			If True then any elements found in mixed content are ignored.
			If False then any child elements cause :class:`GIFTMixedContentError`
			to be raised.

		The default implementation returns a character string and is only supported
		for elements where mixed content is permitted (:py:meth:`is_mixed`).  It uses
		:py:meth:`generate_value` to iterate through the children.

		If the element is empty an empty string is returned.

		Derived classes may return more complex objects, such as values of basic python
		types or class instances that better represent the content of the element.
		"""
		# equivalent to join_characters in py2
		# if isinstance(self, str):
		# 	return self
		# else:
		# 	return join_characters(self.generate_value(ignore_elements))
		return join_characters(self.generate_value(ignore_elements))

	def set_value(self, value):
		"""Replaces the content of the element.

		value
			A character string used to replace the content of the
			element.  Derived classes may support a wider range of
			value types, if the default implementation encounters
			anything other than a character string it attempts to
			convert it before setting the content.

		The default implementation is only supported for elements
		where mixed content is permitted (see :py:meth:`is_mixed`)
		and only affects the internally maintained list of children.
		Elements with more complex mixed models MUST override this
		method.

		If *value is None then the element becomes empty.
		"""
		if not self.is_mixed():
			raise GIFTMixedContentError
		self.reset(False)
		if value is None:
			self._children = []
		else:
			self._children = [str(value)]

	def reset(self, reset_attrs=False):
		"""Resets all children (and optionally attribute values).

		reset_attrs
			Whether or not to reset attribute values too.

			Called by the default implementation of :meth:`set_value`
			with reset_attrs=False, removes all children from the
			internally maintained list of children.

			Called by the default implementation of :meth:`add_child`
			with reset_attrs=True when an existing element instnace is
			being recycled (obviating the constructor).  The default
			implementation removes only *unmapped* attribute values.
			Mapped attribute values are not reset.

		Derived classes should call this method if they override the
		implementation of :meth:`set_value`.

		Derived classes with custom content models, i.e., those that
		provide a custom implementation for :meth:`get_children`, must
		override this method and treat it as an event associated with
		parsing the start tag of the element.  (This method is also a
		useful signal for resetting an state used for validating custom
		content models.)

		Required children should be reset and optional children should
		be orphaned using :meth:`detach_from_parent` and any references
		to them in instance attributes removed. Failure to override this
		method will can result in the child elements accumulating from
		one read to the next.
		"""
		if reset_attrs:
			self._attrs = {}
		for child in self._children:
			if isinstance(child, Element):
				child.detach_from_doc()
				child.parent = None
		self._children = []

	def validation_error(self, msg, data=None, aname=None):
		"""Called when a validation error occurred in this element.

		msg
			Message suitable for logging and reporting the nature of
			the error.

		data
			The data that caused the error may be given in data.

		aname
			The attribute name may also be given indicating that the
			offending data was in an attribute of the element and not
			the element itself.

		The default implementation simply calls the containing Document's
		:meth:`Document.validation_error` method.  If the element is an
		orphan then :class:`GIFTValidityError` is raised directly with *msg*.
		"""
		doc = self.get_document()
		if doc:
			doc.validation_error(msg, self, data, aname)
		else:
			raise GIFTValidityError(msg)

	@staticmethod
	def sort_names(name_list):
		name_list.sort()

	def __eq__(self, other):
		"""Compares another element with this one.

		GIFTElement can only be compared with other Elements.
		"""
		if not isinstance(other, Element):
			return NotImplemented
		if self.giftname != other.giftname:
			return False
		self_attrs = self.get_attributes()
		self_attr_names = list(dict.keys(self_attrs))
		self.sort_names(self_attr_names)
		other_attrs = other.get_attributes()
		other_attr_names = list(dict.keys(other_attrs))
		other.sort_names(other_attr_names)
		if self_attr_names != other_attr_names:
			return False
		for i in range(len(self_attr_names)):
			self_aname = self_attr_names[i]
			if self_attrs[self_aname] != other_attrs[self_aname]:
				return False
		self_children = list(self.get_canonical_children())
		other_children = list(other.get_canonical_children())
		return self_children == other_children

	def __ne__(self, other):
		if not isinstance(other, Element):
			return NotImplemented
		return not self.__eq__(other)

	def __bytes__(self):
		"""Returns the GIFT element as a binary string.

		The resulting string is encoded with UTF-8
		"""
		s = io.BytesIO()
		for data in self.generate_gift():
			s.write(data.encode('utf-8'))
		return s.getvalue()

	def __str__(self):
		"""Returns the GIFT element as a str"""
		s = io.StringIO()
		for data in self.generate_gift(root=True):
			s.write(force_text(data))
		return s.getvalue()

	def deepcopy(self, parent=None):
		"""Creates a deep copy of this element.

		parent
			The parent node to attach the new element to.  If it is None
			then a new orphan element is created.

		This method mimics the process of serialisation and deserialisation
		(without the need to generate markup).  As a result, element
		attributes are serialised and deserialised to strings during the
		copy process.
		"""
		if parent:
			e = parent.add_child(self.__class__, self.get_giftname())
		else:
			e = self.__class__(None)
		attrs = self.get_attributes()
		for aname in dict.keys(attrs):
			e.set_attribute(aname, attrs[aname])
		for child in self.get_children():
			if isinstance(child, str):
				e.add_data(child)
			else:
				child.deepcopy(e)
		e.content_changed()
		return e

	def get_base(self):
		"""Returns the value of the gift:base attribute as a string."""
		return self._attrs.get(_gift_base, None)

	def set_base(self, base):
		"""Set the value of the gift:base attribute from a string.

		Changing the base of an element affects the interpretation of
		all relative URIs in this element and its children."""
		if base is None:
			self._attrs.pop(_gift_base, None)
		else:
			self._attrs[_gift_base] = str(base)

	def resolve_base(self):
		"""Returns the base of the current element.

		The URI is calculated using any gift:base values of the element
		or its ancestors and ultimately relative to the base URI of the
		document itself.

		If the element is not contained by a Document, or the document
		does not have a fully specified base_uri then the return result
		may be a relative path or even None, if no base information is
		available.

		The return result is always None or a character string, such as
		would be obtained from the gift:base attribute.
		"""
		baser = self
		base_uri = None
		while baser:
			rebase = baser.get_base()
			if base_uri:
				# TODO: add the current document
				if rebase:
					base_uri = base_uri.resolve(rebase)
				# base_uri = urlparse.urljoin(rebase, base_uri)
			elif rebase:
				base_uri = uri.URI.from_octets(rebase)
			baser = baser.parent
		return None if base_uri is None else str(base_uri)

	def resolve_uri(self, uriref):
		"""Resolves a URI reference in the current context.

		uriref
			A :class:`pyslet.rfc2396.URI` instance or a string
			that one can be parsed from.

		The argument is resolved relative to the gift:base values
		of the element's ancestors and ultimately relative to the
		document's base.  Their result may still be a relative URI,
		there may be no base set or the base may only be known in
		relative terms.
		"""
		if not isinstance(uriref, uri.URI):
			uriref = uri.URI.from_octets(uriref)
		base_uri = self.resolve_base()
		if base_uri:
			return uriref.resolve(base_uri)
		else:
			return uriref

	def relative_uri(self, href):
		"""Returns href expressed relative to the element's base.

		href
			A :class:`pyslet.rfc2396.URI` instance or a string
			that one can be parsed from.

		If href is already a relative URI then it is converted to a
		fully specified URL by interpreting it as being the URI of
		a *file* expressed relative to the current working directory.

		For example, if the Document was loaded from:

			/path/to/repo/catalog.txt

		and *e* is an element in that document then::

			e.relative_uri('/path/to/repo/smiley.gif')

		would return a URI instance representing relative URI::

			'smiley.gif'

		If the element does not have a fully-specified base path then
		the result is a fully-specified path itself.
		"""
		if not isinstance(href, uri.URI):
			href = uri.URI.from_octets(href)
		if not href.is_absolute():
			href = href.resolve(uri.URI.from_path(os.getcwd()))
		base = self.resolve_base()
		if base is not None:
			return href.relative(base)
		else:
			return href

	def get_lang(self):
		raise NotImplementedError

	def set_lang(self, lang):
		raise NotImplementedError

	def write_gift_attributes(self, attributes, root=False, **kws):
		"""Creates strings serialising the element's attributes

		attributes
			A list of character strings

		escape_function
			The function that will be used to escape character data.  The default is
			:func:`escape_char_data`.  Previous pyslet version kept escape_function parameter
			for backwards compatibility.

		root
			Indicates if this element should be treated as the root element.
			By default there is no special action required but derived classes
			may need to generate additional attributes, such as those that relate
			to the namespaces or schema used by the element.

		The attributes are generated as strings of the form 'name="value"' with values escaped
		appropriately for serialised GIFT output.  The attributes are always sorted into a
		predictable order (based on attribute name) to ensure that identical documents
		produce identical output.
		"""
		attrs = self.get_attributes()
		keys = list(dict.keys(attrs))
		self.sort_names(keys)
		for a in keys:
			attributes.append('%s=%s' % (a, escape_char_data(attrs[a], True)))

	def generate_gift(self, indent='', tab='\t', root=False, **kws):
		"""Element class: A generator that yields serialised GIFT

		This will need some thought to generate in GIFT format

		https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L2766

		Assume escape_function is escape_char_data

		indent (defaults to an empty string)
			The string to use for passing any inherited indent, used in combination
			with the tab parameter for pretty printing.  See below.

		tab (defaults to '\\t')
			Whether or not indentation will be used is determined by the tab parameter.
			If it is empty then no pretty-printing is performed for the element, otherwise
			the element will start with a line-feed followed by an inherited *indent* and
			finally followed by the content of *tab*.  For example, if you prefer to have your
			GIFT serialised with a 4-space indent then pass tab = '    '.

			If the element is in a context where pretty printing is not allowed
			(see :meth:`can_pretty_print`) then tab is ignored.

		root (defaults to False)
			Indicates if this is the root element of the document.  See
			:meth:`write_gift_attributes`.

		Yields character strings.
		"""
		if isinstance(self, Element) and self.giftname == 'endResponses':
			yield '}%s' % self.get_value()
			return
		children = self.get_canonical_children()
		while True:
			try:
				child = next(children)
			except StopIteration:
				break
			if isinstance(child, str):
				logging.debug("string element: %s\n" % child)
				giftname = self.giftname
				value = child
			else:
				logging.debug("not string element: %s\n" % child.giftname)
				giftname = child.giftname
				value = child.get_value()
			if giftname == 'questionTitle':
				yield '::%s' % value
			elif giftname == 'question':
				yield '::%s{' % value
			elif giftname == 'correctResponse':
				yield '=%s' % value
			elif giftname == 'wrongResponse':
				logging.debug("giftname == wrongResponse\n")
				yield '~%s' % value
			elif giftname == 'endResponses':
				logging.debug("giftname == endResponses\n")
				yield '}%s' % value
			else:
				raise GIFTUnsupportedChildTypeError("child giftname: %s" % child.giftname)

	def write_gift(self):
		"""Writes serialized GIFT to an output stream.

		https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L2850
		"""
		raise NotImplementedError


class GIFTDTD(object):
	"""An object that models a document type declaration.

	The document type declaration acts as a container for the entity,
	element and attribute declarations used in a document.
	"""
	def __init__(self):
		self.name = None
		#: The declared Name of the root element
		#: An :py:class:`GIFTExternalID` instance (may be None)
		self.external_id = None
		self.parameter_entities = {}
		"""A dictionary of GIFTParameterEntity instances keyed on entity name."""
		self.general_entities = {}
		"""A dictionary of GIFTGeneralEntity instances keyed on notation name."""
		self.notations = {}
		"""A dictionary of GIFTNotation instances keyed on notation name."""
		self.element_list = {}
		"""A dictionary of :py:class:`EleemntType` definitions keyed on the name of element."""
		self.attribute_lists = {}
		"""A dictionary of dictionaries, keyed on element name.  Each of the resulting dictionaries
		is a dictionary of :py:class:`GIFTAttributeDefinition` keyed on attribute name."""

	def declare_entity(self, entity):
		"""Declares an entity in this document.

		The same method is used for both general and parameter entities.  The value of *entity*
		can be either an :py:class:`GIFTGeneralEntity` or a :py:class:GIFTParameterEntity` instance.
		"""
		if isinstance(entity, GIFTGeneralEntity):
			self.general_entities[entity.name] = entity
		elif isinstance(entity, GIFTParameterEntity):
			self.parameter_entities[entity.name] = entity
		else:
			raise ValueError

	def get_parameter_entity(self, name):
		"""Returns the parameter entity definitions matching *name*.

		Returns an instance of :py:class:`GIFTParameterEntity`. If no
		parameter has been declared with *name* then None is returned.
		"""
		return self.parameter_entities.get(name, None)

	def get_entity(self, name):
		"""Returns the general entity definition matching *name*.

		Returns an instance of :py:class:`GIFTGeneralEntity`. If no
		general has been declared with *name* then None is returned.
		"""
		return self.general_entities.get(name, None)

	def declare_notation(self, notation):
		"""Declares a notation for this document.

		The value of *notation* must be a :py:class:`GIFTNotation` instance.
		"""
		self.notations[notation.name] = notation

	def get_notation(self, name):
		"""Returns the notation declaration matching *name*.

		name
			The name of the notation to search for.

		Returns an instance of :py:class:`GIFTNotation`. If no notation
		has been declared with *name* then None is returned.
		"""
		return self.notations.get(name, None)

	def declare_element_type(self, etype):
		"""Declares an element type.

		etype
			A :py:class:`ElementType` instance containing the element definition.
		"""
		elist = self.element_list.get(etype.name, None)
		if elist is None:
			self.element_list[etype.name] = etype

	def get_element_type(self, element_name):
		"""Looks up an element type definition.

		element_name
			the name of the element type to look up

		The method returns an instance of :py:class:`ElementType` or
		None if no element with that name has been declared.
		"""
		return self.element_list.get(element_name, None)

	def declare_attribute(self, element_name, attr_def):
		raise NotImplementedError

	def get_attribute_list(self, name):
		raise NotImplementedError

	def get_attribute_definition(self, element_name, attr_name):
		raise NotImplementedError



class GIFTContentParticle(object):

	# : Occurrence constant for particles that must appear exactly once
	ExactlyOnce = 0
	ZeroOrOne = 1
	ZeroOrMore = 2
	OneOrMore = 3

	def __init__(self):
		"""An object for representing content particles."""
		self.occurrence = GIFTContentParticle.ExactlyOnce

	def build_particle_maps(self, exit_particles):
		"""Abstract method that builds the particle maps for this node or its children.

		For more information see :py:attr:`GIFTNameParticle.particle_map

		Although only name particles have particle maps this method is called for all
		particle types to allow the model to be built hierarchically from the root out
		to the terminal (name) nodes.  *exit_particles* provides a mapping to all the
		following particles outside the part of the hierarchy rooted at the current node
		that are directly reachable from the particles inside.
		"""
		raise NotImplementedError

	def seek_particles(self, pmap):
		"""Adds all possible entry particles to pmap.

		Abstract method, *pmap* is a mapping from element name to a list
		of :py:class:`XMLNameParticles XMLNameParticle`.

		Returns True if a required particle was added, False if all
		particles added are optional.

		Like :py:meth:`build_particle_maps`, this method is called for
		all particle types.  The mappings requested represent all
		particles inside the part of the hierarchy rooted at the current
		node that are directly reachable from the preceeding particles
		outside.
		"""
		raise NotImplementedError

	def add_particles(self, src_map, pmap):
		"""A utility method that adds particles from src_map to pmap.

		Both maps are mappings from element name to a list of
		:py:class:`GIFTNameParticles GIFTNameParticle`.  All entries in
		*src_map* not currently in *pmap* are added.
		"""
		for name in dict_keys(src_map):
			if name in pmap:
				# add items from src_map[name] to pmap[name]
				target_list = pmap[name]
			elif name:
				# add items to a new list
				pmap[name] = target_list = []
			else:
				# add end tag sentinel
				pmap[name] = target_list = None
			if target_list is not None:
				# this double loop looks dangerous but the lists will
				# usually be 1 or 2 particles long at most
				for ip in src_map[name]:
					dup = False
					for jp in target_list:
						if ip is jp:
							dup = True
							break
					if not dup:
						target_list.append(ip)

	def is_deterministic(self, pmap):
		"""A utility method for identifying deterministic particle maps.

		A deterministic particle map is one in which each name maps uniquely
		to a single content particle. A non-deterministic particle map contains
		an ambiguity, for example ((b,d)|(b,e)).

		The particle map created by :py:meth:`seek_particles` for the enclosing
		choice list would have two entries for 'b', one to map the first particle
		of the first sequence and one to the first particle of the second sequence.

		Although non-deterministic content models are not allowed in SGML they are
		tolerated in XML and are only flagged as compatibility errors.
		"""
		if pmap:
			for name in dict_keys(pmap):
				if pmap[name] is not None and len(pmap[name]) > 1:
					return False
		return True


class GIFTNameParticle(GIFTContentParticle):
	"""Represents a content particle for a named element"""

	def __init__(self):
		GIFTContentParticle.__init__(self)
		#: the name of the element type that matches this particle
		self.name = None
		self.particle_map = {}
		"""Each :py:class:`GIFTNameParticle` has a particle map that
		maps the name of the 'next' element found in the content model
		to the list of possible :py:class:`GIFTNameParticles GIFTNameParticle`
		that represent it in the content model.

		The content model can be traversed using :py:class:`ContentParticleCursor`.
		"""

	def build_particle_maps(self, exit_particles):
		self.particle_map = {}
		if self.occurrence == GIFTContentParticle.ZeroOrMore or \
				self.occurrence == GIFTContentParticle.OneOrMore:
			# repeatable element, add ourselves to the map
			self.particle_map[self.name] = [self]
		self.add_particles(exit_particles, self.particle_map)

	def seek_particles(self, pmap):
		if self.name in pmap:
			target_list = pmap[self.name]
			dup = False
			for p in target_list:
				if p is self:
					dup = True
			if not dup:
				target_list.append(self)
		else:
			pmap[self.name] = [self]
		return self.occurrence == GIFTContentParticle.OneOrMore or \
			self.occurrence == GIFTContentParticle.ExactlyOnce

	def is_deterministic(self):
		return GIFTContentParticle.is_deterministic(self, self.particle_map)


class GIFTChoiceList(GIFTContentParticle):
	def __init__(self):
		raise NotImplementedError

	def build_particle_maps(self, exit_particles):
		raise NotImplementedError

	def seek_particles(self, pmap):
		raise NotImplementedError

	def is_deterministic(self):
		raise NotImplementedError


class GIFTSequenceList(GIFTContentParticle):
	def __init__(self):
		raise NotImplementedError

	def build_particle_maps(self, exit_particles):
		raise NotImplementedError

	def seek_particles(self, pmap):
		raise NotImplementedError

	def is_deterministic(self):
		raise NotImplementedError


class GIFTAttributeDefinition(object):
	"""https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L3103

	"""
	def __init__(self):
		raise NotImplementedError


class Document(Node):
	"""Base class for all GIFT documents.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L550

	With no arguments, a new Document is created with no base URI or root element.

	root
		If root is a class object (descended from :class:`Element`) it
		is used to create the root element of the document.

		If root is an orphan instance of :class:`Element` (i.e., it has no parent)
		it is used as the root element of the document and its
		:py:meth:`Element.attach_to_doc`
		method is called.

	base_uri
		See :meth:`set_base` for more information

	req_manager
		Sets the request manager object to use for future HTTP calls.
		Must be an instance of :class:`pyslet.http.client.Client`.
	"""

	def __init__(self, root=None, base_uri=None, **kws):
		base_uri = kws.get('baseURI', base_uri)
		super(Document, self).__init__()
		# base_uri = kws.get('baseURI', base_uri)
		self.base_uri = None
		self.dtd = None
		self.root = None
		"""The root element or None if no root element has been created yet.
		"""
		if root:
			if isinstance(root, Element):
				if root.parent:
					raise ValueError(
						"Element must be an orphan in Document constructor")
				self.root = root
				root.parent = self
				self.root.attach_to_doc(self)
			elif not issubclass(root, Element):
				raise ValueError
			else:
				self.root = root(self)
		# this will break document constructor unittest.  There should only be a root if one is input.
		# else:
		# 	self.root = Element("root")
		# 	self.root.attach_to_doc(self)
		self.set_base(base_uri)
		self.idTable = {}

	def get_children(self):
		"""Yields the root element"""
		if self.root:
			yield self.root

	def __bytes__(self):
		"""Returns the GIFT document as a string"""
		s = io.BytesIO()
		self.write_gift(s)
		return s.getvalue()

	def __str__(self):
		"""Returns GIFT document as string"""
		s = io.StringIO()
		for data in self.generate_gift():
			s.write(data)
		return s.getvalue()

	def GIFTParser(self, entity):
		"""Creates a parser for this document

		https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L623

		entity
			The entity to parse the document from

		The default implementation creates an instance of :class:`GIFTParser`.

		This method allows some document classes to override the parser used to parse them.
		This method is only used when parsing existing document instances (see :py:meth:`read`
		for more information).

		Classes that override this method may still register themselves with
		:py:func:`register_doc_class` but if they do then the default :py:class:`GIFTParser` object
		will be used as automatic detection of document class is done by the parser itself
		based on the information in the prolog (and/or first element).
		"""
		from pyslet.gift.parser import GIFTParser
		return GIFTParser(entity)

	@classmethod
	def get_element_class(cls, name):
		"""Defaults to returning :class:`Element`.

		Derived classes override this method to enable the GIFT parser to create instances
		of custom classes based on the document context and element name.
		"""
		return Element

	def add_child(self, child_class, name=None):
		"""Creates the root element of the document.

		If there is already a root element it is detached from the document first using
		:py:meth:`Element.detach_from_doc`.

		Unlike :meth:`Element.add_child` there are no model customization options.  The
		root element is always found at :attr:`root`.
		"""
		# if self.root:
		# 	self.root.detach_from_doc()
		# 	self.root.parent = None
		# 	self.root = None
		# child = child_class(self)
		# if name:
		# 	child.set_giftname(name)
		# self.root = child
		# return self.root
		logging.debug("add_child(): name, %s" % name)
		if not self.root:
			self.root = Element("root")
		child = self.root.add_child(child_class, name)
		return child

		# if self.root:
		# 	child = self.root.add_child(child_class, name)
		# 	return child
		# else:
		# 	child = child_class(self)
		# 	if name:
		# 		child.set_giftname(name)
		# 	self.root = child
		# 	return self.root

	def set_base(self, base_uri):
		"""Sets the base_uri of the document to the given URI.

		base_uri
			An object that can be passed to its constructor.

		Relative file paths are resolved relative to the current working
		directory immediately and the absolute URI is recorded as the
		document's *base_uri*.
		"""
		if base_uri is None:
			self.base_uri = None
		else:
			if isinstance(base_uri, uri.URI):
				self.base_uri = base_uri
			else:
				self.base_uri = uri.URI.from_octets(base_uri)
			if not self.base_uri.is_absolute():
				cwd = uri.URI.from_path(
					os.path.join(os.getcwd(), os.curdir))
				self.base_uri = self.base_uri.resolve(cwd)

	def get_base(self):
		"""Returns a string representation of the document's base_uri."""
		if self.base_uri is None:
			return None
		else:
			return str(self.base_uri)

	def get_space(self):
		"""Returns the default space policy for the document.

		By default we return None, indicating that no policy is in force.
		Derived documents can override this behaviour to return either "preserve"
		or "default" to affect space handling.
		"""
		raise NotImplementedError

	def validation_error(self, msg, element, data=None, aname=None):
		"""Called when a validation error is triggered.

		msg
			contains a brief message suitable for describing the error
			in a log file.
		element
			the element in which the validation error occurred
			data, aname

		See :meth:`Element.validation_error`.

		Prior to raising :class:`GIFTValidityError` this method logs a
		suitable message at WARN level."""
		if aname:
			logging.warning("%s (in %s.%s) %s", msg, aname,
				"" if data is None else repr(data))
		else:
			logging.warning("%s (in %s) %s", msg, element.giftname,
				"" if data is None else repr(data))
		raise GIFTValidityError("%s (in %s)" % (msg, element.giftname))

	def register_element(self, element):
		"""Registers an element's ID

		If the element has an ID attribute it is added to the internal
		ID table.  If the ID already exists :class:`GIFTIDClashError` is
		raised.
		"""
		if element.id in self.idTable:
			raise GIFTIDClashError
		else:
			self.idTable[element.id] = element

	def unregister_element(self, element):
		"""Removes an element's ID

		If the element has a uniquely defined ID it is removed from the
		internal ID table.  Called prior to detaching the element from
		the document.
		"""
		if element.id:
			del self.idTable[element.id]

	def get_element_by_id(self, id):
		"""Returns the element with a given ID

		Returns None if the ID is not the ID of any element.
		"""
		return self.idTable.get(id, None)

	def get_unique_id(self, base_str=None):
		"""Generates a random element ID that is not yet defined

		base_str
			A suggested prefix (defaults to None)
		"""
		if not base_str:
			base_str = '%X' % random.randint(0, 0xFFFF)
		id_str = base_str
		id_extra = 0
		while id_str in self.idTable:
			if not id_extra:
				id_extra = random.randint(0, 0xFFFF)
			id_str = '%s-%X' % (base_str, id_extra)
			id_extra = id_extra + 1
		return id_str

	def read(self, src=None, **kws):
		"""Reads this document, parsing it from a source stream.

		With no arguments the document is read from the
		:py:attr:`base_uri` which must have been specified on
		construction or with a call to the :py:meth:`set_base` method.

		src (defaults to None)
			You can override the document's base URI by passing a value
			for *src* which may be an instance of :py:class:`GIFTEntity`
			or a file-like object suitable for passing to
			:meth:`read_from_stream`.
		"""
		if src:
			# Read from this stream, ignore base_uri
			if isinstance(src, GIFTEntity):
				self.read_from_entity(src)
			else:
				self.read_from_stream(src)
		elif self.base_uri is None:
			raise GIFTMissingLocationError
		else:
			with GIFTEntity(self.base_uri) as e:
				self.read_from_entity(e)

	def read_from_stream(self, src):
		"""Reads this document from a stream

		src
			Any object that can be passed to :class:`GIFTEntity`'s
			constructor.
		"""
		self.data = []
		e = GIFTEntity(src)
		self.read_from_entity(e)

	def read_from_entity(self, e):
		"""Reads this document from an entity

		e
			A :class:`GIFTEntity` instance.

		The document is read from the current position in the entity.
		"""
		self.data = []
		parser = self.GIFTParser(e)
		parser.parse_document(self)
		if e.location is not None:
			# update our base_uri from the entity
			self.set_base(e.location)

	def create(self, dst=None, **kws):
		"""Creates the Document.

		Outputs the document as a GIFT stream.

		dst (defaults to None)
			The stream is written to the base_uri by default but
			if the 'dst' argument is provided then it is written
			directly to there instead.  dst can be any object
			that supports the writing of binary strings.

		Currently only documents with file type baseURIs are supported.
		The file's parent directories are create if required.  The
		file is always written using the UTF-8.
		"""
		if dst:
			self.write_gift(dst)
		elif self.base_uri is None:
			raise GIFTMissingLocationError
		elif isinstance(self.base_uri, uri.FileURL):
			fpath = self.base_uri.get_pathname()
			fdir, fname = os.path.split(fpath)
			if not os.path.isdir(fdir):
				os.makedirs(fdir)
			f = open(fpath, 'wb')
			try:
				self.write_gift(f)
			finally:
				f.close()
		else:
			raise GIFTUnsupportedSchemeError(self.base_uri.scheme)

	def generate_gift(self):
		"""A generator that yields serialised XML

		Assume UTF-8 encoding.

		Assume escape_char_data is escape_function.

		Yields character strings.
		"""
		if self.root:
			for s in self.root.generate_gift():
				yield s

	def write_gift(self, writer):
		"""Writes serialized GIFT to an output stream

		writer
			A file or file-like object operating in binary mode.

		The other arguments follow the same pattern as :meth:`generate_gift` which
		this method uses to create the output which is always UTF-8 encoded.
		"""
		for s in self.generate_gift():
			writer.write(s.encode('utf-8'))

	def update(self, **kws):
		"""Updates the Document.

		Update outputs the document as a GIFT stream.
		The stream is written to the base_uri which must already exist.
		"""
		if self.base_uri is None:
			raise GIFTMissingLocationError
		elif isinstance(self.base_uri, uri.FileURL):
			fpath = self.base_uri.get_pathname()
			if not os.path.isfile(fpath):
				raise GIFTMissingResourceError(fpath)
			f = open(fpath, 'wb')
			try:
				self.write_gift(f)
			finally:
				f.close()
		else:
			raise GIFTUnsupportedSchemeError(self.base_uri.scheme)

	def diff_string(self, other_doc, before=10, after=5):
		"""Compares GIFT documents

		other_doc
			Another :class:`Document` instance to compare with.

		before (default 10)
			Number of lines before the first difference to output

		after (default 5)
			Number of lines after the first difference to output

		The two documents are converted to character strings and then
		compared line by line until a difference is found.  The result
		is suitable for logging or error reporting.  Used mainly to make the
		output of unittests easier to understand.
		"""
		pass


class GIFTEntity(object):
	"""Represents a GIFT entity.

	https://github.com/swl10/pyslet/blob/master/pyslet/xml/structures.py#L3188

	This object serves two purposes: it acts as both the object used to store
	information about declared entities and also as a parser for feeding unicode
	characters to the main :py:class:`GIFTParser`.

	src
		May be a character string, a binary string, an instance of
		:py:class:`pyslet.rfc2396.URI`, or any object that supports
		file-like behaviour (seek and read).

		If provided, the corresponding open method is called immediately, see
		:meth:`open_unicode`, :meth:`open_string`, :meth:`open_uri` and
		:meth:`open_file`.

	encoding
		If src is not None then this value will be passed when opening the entity
		reader.

	GIFTEntity objects act as context managers, hence it is possible to use::

		with GIFTEntity(src=URI.from_octets('mydata.txt')) as e:
			# process the entity here, will automatically close

	In Python 3.5 REPL:
	>>> import pyslet.rfc2396 as uri
	>>> uri.URI.from_octets('mygift.txt')
	<pyslet.rfc2396.URI object at 0x10225cfd0>
	"""
	def __init__(self, src=None, encoding=None, **kws):
		self.location = None
		"""the location of this entity (used as the base URI to resolve
		relative links).  A :class:`pyslet.rfc2396.URI` instance."""
		self.encoding = None
		self.data_source = None
		self.char_source = None
		self.close_source = False
		self.bom = False
		"""Flag to indicate whether or not the byte order mark was detected.
		If detect the flag is set to True.  An initial byte order mark is
		not reported in :py:attr:`the_char` or by the :py:meth:`next_char`
		method.
		"""
		self.the_char = None
		"""The character at the current position in the entity"""
		self.line_num = None
		"""The current line number within the entity (first line is line 1)"""
		self.line_pos = None
		"""The current character position within the entity (first char is 1)"""
		self.buff_text = ''
		self.base_pos = None
		self.char_seek = None
		self.chars = ''
		self.char_pos = None
		self.ignore_lf = None
		self.flags = {}
		if isinstance(src, str):
			self.open_unicode(src)
		elif isinstance(src, uri.URI):
			self.open_uri(src)
		elif isinstance(src, bytes):
			self.open_string(src)
		elif src is not None:
			self.open_file(src, encoding)

	chunk_size = io.DEFAULT_BUFFER_SIZE
	"""Characters are read from the data_source in chunks.
	The default chunk size is set from io.DEFAULT_BUFFER_SIZE, typically 8KB.
	"""

	def get_name(self):
		"""Returns a name to represent this entity

		The name is intended for logs and error messages.  It defaults to the location
		if set.
		"""
		if self.location is None:
			return repr(self)
		else:
			return str(self.location)

	def is_external(self):
		"""Returns True if this is an external entity.

		The default implementation returns True if *location* is not
		None, False otherwise."""
		return self.location is not None

	def open(self):
		"""Opens the entity for reading.

		The default implementation uses :py:meth:`open_uri` to open the
		entity from :py:attr:`location` if available, otherwise it raises
		NotImplementedError.
		"""
		if self.location:
			self.open_uri(self.location)
		else:
			raise NotImplementedError

	def is_open(self):
		"""Returns True if the entity is open for reading."""
		return not (self.char_source is None)

	def open_unicode(self, src):
		"""Opens the entity from a unicode string."""
		self.encoding = 'utf-8'
		self.data_source = None
		self.chunk = GIFTEntity.chunk_size
		if PY2:
			src = unicode(src)
		self.char_source = io.StringIO(src)
		self.close_source = True
		self.base_pos = self.char_source.tell()
		self.reset()

	def open_string(self, src):
		"""Opens the entity from a binary string.

		src
			A binary string.

		The advantage of using this method instead of converting
		the string to unicode and calling :py:meth:`open_unicode`
		is that this method creates a unicode reader object to
		parse the string instead of making a copy of it in memory.
		"""
		self.data_source = io.BytesIO(src)
		self.close_source = True
		self.chunk = 1
		self.char_source = codecs.getreader('utf-8')(self.data_source)
		self.base_pos = self.char_source.tell()
		self.reset()

	def open_file(self, src, encoding='utf-8'):
		"""Opens the entity from a file

		Assumes utf-8 encoding.

		src
			An existing (open) binary file.
		"""
		self.encoding = 'utf-8'
		self.char_source = src
		self.data_source = None
		self.chunk = 1
		self.base_pos = self.char_source.tell()
		self.reset()

	def open_uri(self, src, **kws):
		"""Opens the entity from a URI.

		Assumes utf-8 encoding.

		src
			A :class:`pyslet.rfc2396.URI` instance of a file
		"""
		self.location = src
		if isinstance(src, uri.FileURL):
			self.data_source = open(src.get_pathname(), 'rb')
			self.close_source = True
			self.encoding = 'utf-8'
			self.open_file(self.data_source, self.encoding)
		else:
			raise GIFTUnsupportedSchemeError

	def reset(self):
		"""Resets an open entity

		The entity returns to the first character in the entity."""
		if self.char_source is None:
			self.the_char = None
			self.base_pos = None
		else:
			self.char_source.seek(self.base_pos)
			self.the_char = ''
		self.line_num = 1
		self.line_pos = 0
		self.chars = ''
		self.char_seek = self.base_pos
		self.char_pos = -1
		self.ignore_lf = False
		self.next_char()
		if self.the_char == character(0xFEFF):
			self.next_char()

	def get_position_str(self):
		"""A short string describing the current position.

		For example, if the current character is pointing to character 6 of line 4
		then it will return the string 'Line 4.6'
		"""
		return "Line %i.%i" % (self.line_num, self.line_pos)

	def next_char(self):
		"""Advances to the next character in an open entity.

		This method takes care of the End-of-Line handling rules which force us to
		remove any CR characters and replace them with LF if they appear no their own or
		to silently drop them if they appear as part of a CR-LEF combination.
		"""
		if self.the_char is None:
			return
		self.char_pos = self.char_pos + 1
		self.line_pos = self.line_pos + 1
		if self.char_pos >= len(self.chars):
			self.char_seek = self.char_source.tell()
			self.chars = self.char_source.read(self.chunk)
			self.char_pos = 0
		if self.char_pos >= len(self.chars):
			self.the_char = None
		else:
			self.the_char = self.chars[self.char_pos]
			if self.the_char == '\x0D':
				# change to a line feed and ignore the next line feed
				self.the_char = '\x0A'
				self.ignore_lf = True
				self.next_line()
			elif self.the_char == '\x0A':
				if self.ignore_lf:
					self.ignore_lf = False
					self.next_char()
				else:
					self.next_line()
			else:
				self.ignore_lf = False

	magic_table = {
		# UCS-4, big-endian machine (1234 order)
		b'\x00\x00\xfe\xff': ('utf_32_be', 4, True),
		# UCS-4, little-endian machine (4321 order)
		b'\xff\xfe\x00\x00': ('utf_32_le', 4, True),
		# UCS-4, unusual octet order (2143)
		b'\x00\x00\xff\xfe': ('utf_32', 4, True),
		# UCS-4, unusual octet order (3412)
		b'\xfe\xff\x00\x00': ('utf_32', 4, True),
		# UTF-16, big-endian
		b'\xfe\xff': ('utf_16_be', 2, True),
		# UTF-16, little-endian
		b'\xff\xfe': ('utf_16_le', 2, True),
		# UTF-8 with byte order mark
		b'\xef\xbb\xbf': ('utf-8', 3, True),
		# UCS-4 or other encoding with a big-endian 32-bit code unit
		b'\x00\x00\x00\x3c': ('utf_32_be', 0, False),
		# UCS-4 or other encoding with a little-endian 32-bit code unit
		b'\x3c\x00\x00\x00': ('utf_32_le', 0, False),
		# UCS-4 or other encoding with an unusual 32-bit code unit
		b'\x00\x00\x3c\x00': ('utf_32_le', 0, False),
		# UCS-4 or other encoding with an unusual 32-bit code unit
		b'\x00\x3c\x00\x00': ('utf_32_le', 0, False),
		# UTF-16BE or big-endian ISO-10646-UCS-2 or other encoding with a
		# 16-bit code unit
		b'\x00\x3c\x00\x3f': ('utf_16_be', 0, False),
		# UTF-16LE or little-endian ISO-10646-UCS-2 or other encoding with
		# a 16-bit code unit
		b'\x3c\x00\x3f\x00': ('utf_16_le', 0, False),
		# UTF-8, ISO 646, ASCII or similar
		b'\3c\x3f\x78\x6D': ('utf_8', 0, False),
		# EBCDIC (in some flavor)
		b'\4c\x6f\xa7\x94': ('cp500', 0, False)
	}

	def auto_detect_encoding(self, src_file):
		"""Auto-detects the character encoding

		src_file
			A file object.  The object must support seek and blocking
			read operations.  If src_file has been opened in text mode
			then no action is taken."""
		src_file.seek(0)
		magic = src_file.read(4)
		if isinstance(magic, str):
			src_file.seek(0)
			return
		while len(magic) < 4:
			magic = magic + b'Q'
		if magic[:2] == b'\xff\xfe' or magic[:2] == b'\xfe\xff':
			if magic[2:] != b'\x00\x00':
				magic = magic[:2]
		elif magic[:3] == b'\xef\xbb\xbf':
			magic = magic[:3]
		self.encoding, seek_pos, self.bom = self.magic_table.get(
			magic, ('utf-8', 0, False))
		src_file.seek(seek_pos)

	def next_line(self):
		"""Called when the entity reader detects a new line.

		This method increases the internal line count and resets the
		character position to the beginning of the line.  You will not
		normally need to call this directly as line handling is done
		automatically by :py:meth:`next_char`.
		"""
		self.line_num = self.line_num + 1
		self.line_pos = 0

	def close(self):
		"""Closes the entity."""
		if self.close_source:
			if self.char_source is not None:
				self.char_source.close()
				self.char_source = None
			if self.data_source is not None:
				self.data_source.close()
				self.data_source = None
			self.close_source = False
		self.the_char = None
		self.line_num = None
		self.line_pos = None

	def __enter__(self):
		return self

	def __exit__(self, exc_type, exc_value, traceback):
		self.close()


class GIFTGeneralEntity(GIFTEntity):
	"""Represents a general entity.

	name
		Optional name

	definition
		An optional definition

	notation
		An optional notation
	"""
	def __init__(self, name=None, definition=None, notation=None):
		GIFTEntity.__init__(self, name, definition)
		self.notation = notation

	def get_name(self):
		raise NotImplementedError


class GIFTParameterEntity(GIFTEntity):
	def __init__(self, name=None, definition=None):
		raise NotImplementedError


class GIFTExternalID(object):
	"""Represents external references to entities.

	public
		An optional public identifier

	system
		An optional system identifier
	"""
	def __init__(self, public=None, system=None):
		self.public = public  # : the public identifier, may be None
		self.system = system  # : the system identifier, may be None

	def get_location(self, base=None):
		"""Get an absolute URI for the external entity.

		Returns a :py:class:`pyslet.rfc2396.URI` resolved against
		:py:attr:`base` if applicable.  If there is no system identifier
		then None is returned."""
		if self.system:
			if base:
				location = uri.URI.from_octets(self.system).resolve(base)
			else:
				location = uri.URI.from_octets(self.system)
			if not location.is_absolute():
				cwd = uri.URI.from_path(
					os.path.join(os.getcwd(), os.curdir))
				location = location.resolve(cwd)
			if location.is_absolute():
				return location
		return None


class GIFTNotation(object):
	def __init__(self, name, external_id):
		#: the notation name
		self.name = name
		#: the external ID of the notation (a GIFTExternalID instance)
		self.external_id = external_id


def map_class_elements(class_map, scope):
	"""Adds element name -> class mappings to class_map

	class_map
		A dictionary that maps GIFT element names onto class objects that
		should be used to represent them.

	scope
		A dictionary, or an object containing a __dict__ attribute, that
		will be scanned for class objects to add to the mapping.  This
		enables scope to be a module.  The search is not recursive, to
		add class elements from imported modules you must call
		map_class_elements for each module.

	Mappings are added for each class that is derived from
	:class:`Element` that has an GIFTNAME attribute defined.  It is an
	error if a class is found with an GIFTNAME that has already been
	mapped."""
	if not isinstance(scope, dict):
		scope = scope.__dict__
	# scope is a namespace, mappingproxy
	for name, obj in scope.items():
		if issubclass(type(obj), type) and issubclass(obj, Element):
			if hasattr(obj, 'GIFTNAME'):
				if obj.GIFTNAME in class_map:
					raise DuplicateGIFTNAME(
						"%s and %s have matching GIFTNAMEs" %
						(obj.__name__, class_map[
							obj.GIFTNAME].__name__))
				class_map[obj.GIFTNAME] = obj
